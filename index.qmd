---
title: "Exercices M√©thodes II"
date: 2025-03-07
author:
  - name: Julian Maitra
    orcid: 0000-0003-3989-5158
    email: julian.maitra@unifr.ch
    affiliation: 
      - name: Universit√© de Fribourg
        url: https://www.unifr.ch/home/en/
license: "MIT"
copyright: 
  holder: Julian Maitra
  year: 2024
format: html
editor: visual
toc: true
toc-depth: 2
toc-location: left
toc-title: Table des mati√®res
---

{{< pagebreak >}} \# Session 1 \| Introduction

**Sujet : Bienvenue, pourquoi R ? et commandes de base I**

```{r}
#| echo: false
#| output: false
library(formatR)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
```

Bienvenue dans la premi√®re le√ßon du cours **Exercices M√©thode II** du
Bachelor en sciences de la communication √† l'Universit√© de Fribourg !

Sur cette page Github, je vous guiderai dans vos premiers pas avec R.

::: {.callout-note icon="true"}
## √Ä noter

**R** est un langage de programmation et un environnement logiciel pour
l'analyse statistique, la visualisation de donn√©es et le calcul
scientifique. Il est largement utilis√© par les statisticiens, les
chercheurs en sciences des donn√©es et de plus en plus en sciences
sociales y compris en sciences de la communication.

R est id√©al pour la manipulation, l'analyse, la mod√©lisation et la
visualisation de donn√©es. C'est un logiciel libre et open source, ce qui
signifie qu'il est gratuit √† utiliser, modifier et distribuer. Il
dispose d'une grande communaut√© d'utilisateurs et de d√©veloppeurs qui
contribuent √† son d√©veloppement et √† sa maintenance.
:::

## Installer les logiciels R et RStudio

Pour utiliser R sur votre ordinateur portable, vous devez d'abord
installer les deux logiciels suivants :

1.  le langage de programmation [R](https://cran.r-project.org)
2.  l'interface [RStudio](https://posit.co/download/rstudio-desktop/)

Notez que nous n'√©crirons le code R que dans RStudio, l'interface. Le
langage de programmation R doit d'abord √™tre install√©, mais il
fonctionnera ensuite en arri√®re-plan. Il n'est donc pas n√©cessaire
d'ouvrir R directement sur votre ordinateur par la suite.

## L'interface RStudio

![Volets RStudio [Source :
posit.co](https://docs.posit.co/ide/user/ide/guide/ui/ui-panes.html)](https://docs.posit.co/ide/user/ide/guide/ui/images/rstudio-panes-labeled.jpeg)

Dans RStudio, il existe quatre volets diff√©rents :

1.  Le volet **source**
2.  Le volet **console**
3.  Le volet **environnement**
4.  Le volet **output**

## Ex√©cuter un script R

Nous travaillons principalement dans le volet **source**, c'est l√† que
nous √©crivons notre code.

Vous pouvez ouvrir le volet source en cr√©ant un nouveau **R script**
(cliquez sur le signe plus vert dans le coin sup√©rieur gauche).

Vous pouvez r√©√©crire ou copier-coller le calcul simple suivant et
l'ins√©rer dans votre script :

```{r}
#| echo: true
#| output: false
10+14
```

Une fois que nous avons √©crit du code R dans le script, nous pouvons
**l'ex√©cuter** en le s√©lectionnant et en cliquant sur le bouton
d'ex√©cution situ√© au-dessus du volet source (le bouton d'ex√©cution avec
la fl√®che verte √† qui montre √† droite).

C'est alors dans le volet de la **console** o√π le r√©sultat va √™tre
affich√© :

```{r}
#| echo: false
#| output: true
10+14
```

Notez que le nombre entre crochets indique la ligne du r√©sultat. Ici, il
s'agit de 1 car il n'y a qu'une seule ligne.

Voici quelques autres calculs simples, suivi de leurs r√©sultats :

```{r}
#| echo: true
#| output: true
1+2
99-98
2*10
100/2

2^10
```

::: {.callout-tip title="Astuce"}
Pour ex√©cuter le code R plus rapidement, vous pouvez placer votre
curseur sur une ligne de code √† ex√©cuter et utiliser les raccourcis
clavier suivants :

-   Sur **Windows** : <kbd>CTRL</kbd> + <kbd>Enter</kbd>

-   Sur **MacOS** : <kbd>Command</kbd> + <kbd>Enter</kbd>
:::

## Commenter votre code avec un `#`

C'est une bonne pratique de **commenter** son code R. Les commentaires
expliquent ce que le code fait et facilite l'utilisation ult√©rieure et
aussi le partage de code entre personnes (qui ne savent peut-√™tre pas ce
que vous vouliez faire avec votre code).

On commente en ajoutant un symbole **`#`** au d√©but de la ligne de code,
comme ceci :

```{r}
# Ceci est un commentaire, et R l'ignorera lors de l'ex√©cution du script.
```

## L'op√©rateur d'affectation `<-`

L'op√©rateur d'affectation **`<-`** est un op√©rateur cl√© de la
programmation R. Il permet d'attribuer des valeurs aux variables.

```{r}
#| echo: true
# Par exemple, nous pouvons attribuer la valeur 5 √† la variable x :
x <- 5
```

Si vous ex√©cutez ce code, une nouvelle variable, `x`, sera cr√©√©e dans le
volet **environnement** en haut √† droite de RStudio.

{{< pagebreak >}}

::: {.callout-note icon="true"}
## √Ä noter

En g√©n√©ral, la programmation R parle aussi d'**objets**, ou de
**structures de donn√©es**, que vous pouvez cr√©er. C'est pourquoi R est
√©galement appel√© **langage de programmation orient√© objet**. Les
variables √† un √©l√©ment sont des objets tr√®s simples. Au cours de ce
cours, nous d√©couvrirons d'autres types d'objets.
:::

::: {.callout-tip title="Astuce"}
Vous pouvez cr√©er l'op√©rateur d'affectation `<-` avec les raccourcis
clavier suivants :

-   Sur **Windows** : <kbd>Alt</kbd> + <kbd>-</kbd>

-   Sur **MacOS** : <kbd>Option</kbd> + <kbd>-</kbd>
:::

## Variables √† √©l√©ment unique

Vous pouvez **imprimer** (afficher) la valeur d'une variable que vous
avez cr√©√©e, telle que `x`, en tapant le nom de la variable et en
l'ex√©cutant.

```{r}
#| echo: true
x
```

::: {.callout-important title="Important"}
-   Veillez toujours √† ex√©cuter votre code pour cr√©er des variables
    avant de les utiliser pour d'autres op√©rations. Si vous oubliez de
    cr√©er les variables en premier, vous obtiendrez une erreur comme
    r√©sultat.
:::

Par exemple, essayez d'ex√©cuter ce qui suit : `y + z`

Pourquoi cela cr√©e une erreur ? R√©ponse : les variables `y` et `z` n'on
pas encore √©t√© d√©finies !

Pour √©liminer l'erreur, nous devons donc d√©finir `y` et `z`.

```{r}
#| echo: true
#| output: true
y <- 7
z <- 3 

# Essayons encore une fois :
y + z
```

Maintenant √ßa marche ! üòÄ

::: {.callout-important title="Important"}
-   Sachez aussi que si vous attribuez une nouvelle valeur √† une
    variable existante, l'ancienne valeur sera √©cras√©e !
:::

```{r}
#| echo: true
# Notez que si vous ex√©cutez toutes les lignes de code suivantes, la variable x se voit attribuer la derni√®re valeur ex√©cut√©e : 4. Les valeurs 5 et 100 sont ecras√©es lors de l'ex√©cution du code.
x <- 5
x <- 100
x <- 4
x
```

### Les diff√©rents types de variable : num√©riques, textuelles et logique

Jusqu'√† pr√©sent, nous avons cr√©√© des variables de **type num√©rique**,
telles que `x` (valeur = 5).

Cependant, ce n'est pas le seul type de variable dans R.

::: {.callout-note icon="true"}
## √Ä noter

Dans R, il existe diff√©rents types de variables :

-   les variables **num√©riques**

-   les variables **textuelles**, √©galement appel√©es *character strings*
    (cha√Ænes de caract√®res).

-   les variables **logiques** avec les valeurs TRUE et FALSE (VRAI et
    FAUX)
:::

```{r}
#| echo: true
# Regardons quelques exemples avec du code ! (faut tout ex√©cuter !)

# variables num√©riques :
a <- 100
b <- 77

age <- 21
Insta_likes <- 1539

# variables textuelles (toujours ajouter des guillemets !)
c <- "chien"
d <- "chat"

Comm_TikTok <- "wsh"
Moliere <- "il n‚Äôest rien d‚Äô√©gal au tabac : c‚Äôest la passion des honn√™tes gens"

# variables logiques :

e <- TRUE
f <- FALSE
```

Les variables logiques peuvent √™tre utiles quand vous travaillez avec
des **cat√©gories binaires**.

Par exemple : il est souvent utile de classer les personnes ayant
r√©pondu √† un questionnaire en cat√©gories binaires, telles que :

-   homme/femme

-   mineur/majeur

-   conservateur/lib√©ral

-   etc.

```{r}
#| echo: true
# Si Marc √©tait mineur et Claire majeure, nous les classerions comme suit : 

Marc <- FALSE
Claire <- TRUE

# Dans cet exemple, la variable logique indique si une personne est majeure (TRUE) ou pas (FALSE)

```

## Variables √† plusieurs √©l√©ments : vecteurs

Les **vecteurs** constituent un autre type de variable (ou type d'objet)
essentiel dans la programmation R. Il s'agit de variables comportant
**plusieurs** √©l√©ments.

Vous pouvez cr√©er des vecteurs avec l'op√©rateur d'affectation `<-` et la
**fonction de concatenation** `c()`.

```{r}
#| echo: true
# Voici quelques exemples avec du code ! (faut tout ex√©cuter !)

# un vecteur num√©rique (notez qu'il faut toujours s√©parer les valeurs avec des virgules)
v1 <- c(1, 2, 3)
```

Vous pouvez afficher la valeur de `v1` en tappant son nom et l'ex√©cutant
:

```{r}
#| echo: true
v1 
```

::: {.callout-note icon="true"}
## √Ä noter

En R, une **fonction** est un morceau de code con√ßu pour effectuer une
t√¢che sp√©cifique, souvent avec des param√®tres variables. Ces param√®tres
d'entr√©e sont √©galement appel√©s les **arguments** de la fonction.
:::

Prenons l'exemple de la fonction `c()` qui cr√©e des vecteurs :

-   les arguments de cette fonction doivent √™tre ins√©r√©s entre les
    crochets sous la forme de valeurs s√©par√©es par des virgules (pour
    chaque √©l√©ment du vecteur).

-   Un vecteur √† deux √©l√©ments : `c(2, 4)`

-   Un vecteur √† trois √©l√©ments : `c(3, 6, 9)`

Maintenant, regardons encores quelques exemples de vecteurs de
**diff√©rents types** :

```{r}
#| echo: true
# vecteurs num√©riques 
w <- c(-10, 100, 4, -88)

likes_comments_shares <- c(513, 34, 102)

# vecteurs textuels (toujours ajouter des guillemets pour chaque √©l√©ment !)
animaux <- c("chat", "chien", "cheval", "chenille")

Comm_Insta <- c("trop cool", "wsh", "c'est quoi ?")

humains <- c("Claire", "Clarissa", "Theresa", "Marc", "Alma")

# vecteurs logiques :
femme <- c(TRUE, TRUE, TRUE, FALSE, TRUE)

```

::: {.callout-caution collapse="false"}
## Attention

Dans R, on ne peut g√©n√©ralement pas m√©langer les valeurs num√©riques,
textuelles et logiques dans le m√™me vecteur !
:::

### Devoir pour Session 2

-   Si ce n'est pas encore fait : Installez R et RStudio sur votre
    ordinateur.

-   Lisez ensuite encore une fois ce script et ex√©cutez toutes les
    sections de code sur votre ordinateur.

-   Essayez de r√©soudre vous-m√™me les √©ventuels messages d'erreur en
    adaptant le code.

{{< pagebreak >}}

# Session 2 \| Commandes de base II

## R√©p√©tition rapide de session 1

```{r}
#| echo: true
#| output: false
#| error: true
# Script de r√©p√©tition

# Avez-vous compris comment R traite les diff√©rents types de variables ?
# Quelle est la diff√©rence entre a et b ?

a <- 5
b <- "5"

# Comment afficher a et b ?


# Alternative : avec la fonction print(), qui augmente la compr√©hension ult√©rieure du code


# Pourquoi le code suivant produit-il une erreur ?
a*b

# Le code suivant corrige √† nouveau l'erreur, pourquoi ?
b <- 5
a*b

# V√©cteurs
v1 <- c(1,2,3,4)
v1

# Vous pouvez cr√©ez des nombres succesifs avec un colon :
v2 <- c(1:10)
v2

v3 <- c("salut", "le", "pote")
v4 <- c(TRUE, FALSE, FALSE)

```

::: {.callout-tip title="Astuce"}
Vous pouvez utiliser la fonction `class()` pour v√©rifier le type d'un
objet, p. ex. (ex√©cutez vous-m√™me !) :

-   `class(c(1,2,3))`

-   `class(c("Hello", "World"))`

-   `class(c(TRUE,TRUE,FALSE))`
:::

## Donn√©es en forme de tableau

Les donn√©es sous forme de tableaux, avec des lignes et des colonnes,
sont au c≈ìur des m√©thodes quantitatives dans les sciences de la
communication.

Dans R, il existe plusieurs structures de donn√©es en format de tableau,
notamment :

-   Les **matrices**

-   Les **data frames**

-   D'autres types, tels que les **tibbles**, qui sont en fait des data
    frames adapt√©s √† des paquets R sp√©cifiques (nous traiterons ce sujet
    plus tard dans le cours).

::: {.callout-important title="Important"}
-   Il est de convention qu'un tableau de donn√©es pr√©sente les **unit√©s
    statistiques** par **ligne** (angl. *row*).
-   Les **variables** ou caract√©ristiques de ces unit√©s statistiques
    sont indiqu√©es en cons√©quence par **colonnes** (angl. *column*).
:::

::: {.callout-note icon="true"}
## √Ä noter

Selon le type de donn√©es, surtout en recherche empirique en sciences
sociales dont font partie les sciences de la communication, les unit√©s
statistiques peuvent √™tre :

-   des **participants** √† un questionnaire ou √† une exp√©rimentation

-   des **documents** (p. ex. articles de presse, posts sur r√©seaux
    sociaux)

-   des **observations/ cas** (p. ex. des profils sur r√©seaux sociaux,
    des entreprises m√©diatiques)

Dans ces jeux de donn√©es, par convention, chaque ligne repr√©sente une
unit√© statistique (ou un participant, un document, une observation),
tandis que chaque colonne repr√©sente les variables qui ont √©t√©
collect√©es pour chaque unit√© statistique.
:::

::: {.callout-note icon="true"}
## √Ä noter

La taille d'un jeu de donn√©es est indiqu√©e par **le nombre d'unit√©s
statistiques n**.

-   Par exemple, si 49 personnes ont r√©pondu √† un questionnaire, nous
    parlons donc d'un √©chantillon de n = 49 participants.
:::

Voici un mod√®le de la mani√®re dont on devrait structurer les r√©ponses √†
un questionnaire avec n participants et X questions :

```{r}
#| echo: false
#| output: true
id <- c("personne_1", "personne_2", "personne_3", "etc.", "personne_n")
question_A <- c("r√©ponse_a_A", "r√©ponse_a_A", "r√©ponse_a_A", "...", "r√©ponse_a_A")
question_B <- c("r√©ponse_a_B", "r√©ponse_a_B", "r√©ponse_a_B", "...", "r√©ponse_a_B")
question_C <- c("r√©ponse_a_C", "r√©ponse_a_C", "r√©ponse_a_C", "...", "r√©ponse_a_C")
etc. <- c("...", "...", "...", "...", "...")
question_X <- c("r√©ponse_a_X", "r√©ponse_a_X", "r√©ponse_a_X", "...", "r√©ponse_a_X")

questionnaire = data.frame(id, question_A, question_B, question_C, etc., question_X)
questionnaire
```

Dans ce mod√®le, l'unit√© statistique de ce jeu de donn√©es est la personne
qui a r√©pondue au questionnaire (un participant). Chaque ligne
correspond donc √† une personne diff√©rente. Les variables, en revanche,
sont les diff√©rentes questions qui ont √©t√© enregistr√©es pour chaque
participant.

Regardons maintenant quelques objets R sous forme de tableau :

## Les matrices

Les **matrices** sont des objets plut√¥t math√©matique. Elles doivent
notamment √™tre compos√© de donn√©es de m√™me type, c'est √† dire num√©rique,
textuel, logique, etc.

On peut cr√©er des objets matriciels avec la commande **`matrix()`**,
avec les arguments suivants :

-   un vecteur de valeurs (p. ex. `c(1,2,3,4,5,6)`)

-   le nombre de lignes (`nrow=`),

-   le nombre de colonnes (`ncol=`) et

-   la *direction* de remplissage des valeurs, c'est-√†-dire par lignes
    (`byrow = TRUE`) ou par colonnes (`byrow = FALSE`).

Cr√©ons quelques matrices exemplaires avec du code R maintenant.

```{r}
#| echo: true
#| output: false
m1 <- matrix(c(1,2,3,4,5,6), nrow = 2, ncol = 3, byrow = FALSE)

print(m1)


m2 <- matrix(c(1:6), nrow = 2, ncol = 3, byrow = TRUE)

print(m2)

# Quelle est la diff√©rence entre m1 et m2 au niveau du code ?

```

::: {.callout-note icon="true"}
## √Ä noter

Si vous ne sp√©cifier pas tous les arguments d'une fonction, R va tenter
d'utiliser des arguments par d√©fauts.
:::

```{r}
# On peut p. ex. cr√©er une matrice sans sp√©cifier tout les arguments de la fonction matrix()
m3 <- matrix(c(1:10), nrow = 5)

print(m3)
```

Vous pouvez extraire des √©l√©ments individuels ou des parties d'une
matrice avec des **parenth√®ses carr√©es `[]`** en sp√©cifiant les lignes
et les colonnes concern√©es.

```{r}
#| echo: true
#| output: true
# Cr√©ons d'abord un matrice m4 avec 100 √©l√©ments :
m4 <-  matrix(c(1:100), nrow = 10, byrow = TRUE)
print(m4)

# Extraire le deuxi√®me √©l√©ment de la troisi√®me ligne :
m4[3,2]

# Extraire les cinq premiers √©l√©ments de la dixi√®me ligne :
m4[10, c(1:5)]

# Extraire tous les √©l√©ments de la premi√®re ligne :
m4[1,]

# Extraire tous les √©l√©ments de la troisi√®me colonne :
m4[,3]

# Extraire la moiti√© sup√©rieure de la matrice :
m4[c(6:10),]

```

## Les data frames

::: {.callout-note icon="true"}
## √Ä noter

Les **data frames** (fran√ßais : *cadre de donn√©es*) sont le type de
donn√©e en forme tableau le plus commun dans R. Cette structure de donn√©e
peut notamment √™tre compos√© de donn√©es de diff√©rents types (num√©rique,
textuel, logique).
:::

Cr√©ons un data frame avec la fonction `data.frame()` maintenant. Nous
appelons ce type d'objets d√©sormais un **jeu de donn√©es**.

![Le film √Çge de glace [Source :
wikimedia.org](https://en.wikipedia.org/wiki/File:Ice_Age_Dawn_of_the_Dinosaurs_theatrical_poster.jpg)](https://upload.wikimedia.org/wikipedia/en/2/24/Ice_Age_Dawn_of_the_Dinosaurs_theatrical_poster.jpg)

```{r}
#| echo: true
#| output: false

# Cr√©ons d'abord un vecteur textuel avec les noms de certains animaux du film L'√¢ge de glace.
name <- c("Manny", "Sid", "Diego", "Ellie", 
          "Peaches", "Scrat", "Rudy", "Buck")

#Un second vecteur textuel indique l'esp√®ce de chaque animal.
species <- c("mammoth", "sloth", "sabertooth", "mammoth", 
             "mammoth", "squirrel", "dinosaur", "weasel")

# Un troisi√®me vecteur logique indique si chaque animal est une femelle
female <- c(FALSE, FALSE, FALSE, TRUE, 
            TRUE, FALSE, FALSE, FALSE)

# Un quatri√®me vecteur num√©rique indique l'√¢ge en ann√©es de chaque animal.
age <- c(30, 20, 35, 25, 
         7, 4, 100, 28)

# Un cinqui√®me tableau num√©rique indique le poids en kg de chaque animal.
weight <- c(5000, 80, 400, 4000, 
            1000, 1, 10000, 3)

# La fonction data.frame() permet d'utiliser les vecteurs pour former un tableau de donn√©es.
ice_age_df <- data.frame(name, species, female, age, weight)

```

Nous pouvons afficher l'objet `ice_age_df` en ex√©cutant son nom ou en
utilisant la fonction `print()` :

```{r}
print(ice_age_df)
```

### Quelques fonctions utiles pour analyser les data frames

Il existe plusieurs **fonctions utiles** dans R qui vous permettent
d'analyser les propri√©t√©s de jex de donn√©es de type data frame (et
d'autres types d'objets R), comme p. ex. :

-   `dim()` : Retourne les dimensions d'un jeu de donn√©es - le nombre de
    lignes et de colonnes.

-   `head()` : Affiche les six premi√®res lignes du jeu de donn√©es.

-   `str()` : Fournit la structure du jeu de donn√©es, y compris

    -   le type de variable de chaque colonne,

    -   le nombre d'observations et

    -   les premi√®res entr√©es de chaque colonne.

        C'est un moyen rapide de se faire une id√©e du contenu de votre
        jeu de donn√©es.

-   `summary()`: Donne un r√©sum√© du jeu de donn√©es, y compris des
    statistiques telles que

    -   la moyenne,

    -   la m√©diane,

    -   le minimum et le maximum pour les variables num√©riques, et

    -   les fr√©quences pour les variables factorielles.

        Cette fonction est utile pour obtenir rapidement une vue
        d'ensemble des statistiques.

```{r}
#| echo: true
#| output: true

# Utilisons ces fonctions pour analyser l'objet ice_age_df

dim(ice_age_df)
head(ice_age_df)
str(ice_age_df)
summary(ice_age_df)

```

::: {.callout-tip title="Astuce"}
Une autre astuce utile consiste √† utiliser le **`$`** pour **extraire
des colonnes sp√©cifiques** d'un jeu de donn√©es.
:::

```{r}
#| echo: true
#| output: true
# P. ex. :
ice_age_df$name

# Essayez vous-m√™me et extrayez d'autres colonnes de ice_age_df √† l'aide du $ !
```

## Fonctions statistiques de base

Il existe dans R toute une palette de fonctions statistiques qui vous
permettent d'√©valuer principalement des donn√©es de type num√©rique.
Quelques fonctions utiles pour les statistiques descriptives de base :

-   `mean()` : Calcule la moyenne arithm√©tique

-   `median()` : Calcule la m√©diane

-   `sd()` : Calcule l'√©cart-type (angl. *standard deviation*)

-   `var()` : Calcule la variance

```{r}
#| echo: true
#| output: false
a1 <- c(1,2,100)

mean(a1)

median(a1)

sd(a1)

var(a1)
```

```{r}
#| echo: false
#| output: true
a1 <- c(1,2,100)

mean(a1)

median(a1)

sd(a1)

var(a1)
```

## Les facteurs

Un autre type de variable cl√© dans R est ce que l'on appelle les
**facteurs**, qui sont essentiellement des **variables cat√©gorielles**.

::: {.callout-note icon="true"}
## √Ä noter

Les facteurs sont des variables qui prennent un nombre limit√© de valeurs
diff√©rentes (appel√©es *levels* dans R).

Il existe deux sous-type de facteurs :

-   Les **facteurs nominaux** (sans ordre) : toutes les cat√©gories sont
    √©quivalentes les unes aux autres. Il n'y a pas de hi√©rarchisation.

    -   Exemples : le genre et l'appartenance √† un parti politique

-   Les **facteurs ordinaux** (avec un ordre): il y a un ordre ou une
    hi√©rarchie sp√©cifi√© parmi les cat√©gories (p. ex. des niveaux tels
    que *faible*, *moyen*, *√©lev√©*).

    -   Exemples : niveau d'√©ducation, cohortes d'√¢ge
:::

Vous pouvez cr√©er un facteur nominal √† l'aide de la fonction `factor()`
et v√©rifier ses cat√©gories avec `levels()`. Voici un exemple :

```{r}
#| echo: true
#| output: true
# Cr√©er un vecteur de donn√©es cat√©gorielles, d'abord de type textuel
genre <- c("homme", "femme", "femme", "femme", "homme")

# Le convertir ensuite en facteur
facteur_genre <- factor(genre)

# Voir les niveaux du facteur genre
levels(facteur_genre)

# Imprimer le facteur (montre aussi les niveaux)
print(facteur_genre)
```

Et voici comment cr√©er un facteur ordinal :

```{r}
#| echo: true
#| output: true
# Voici un vecteur textuel avec des tailles de T-shirt
tailles <- c("Small", "Medium", "Large", "Medium", "Small")

# On le transforme en facteur ordinal en sp√©cifiant les arguments suivants :
tailles_facteur <- factor(tailles, order = TRUE, levels = c("Small", "Medium", "Large"))

levels(tailles_facteur)

print(tailles_facteur)

```

Transformons maintenant la colonne `species` de notre jeu de donn√©es
`ice_age_df` en facteur avec la fonction `as.factor()`:

```{r}
#| echo: true
#| output: true
# V√©rifions d'abord la structure de l'objet ice_age_df :
str(ice_age_df)

# Transformation en facteur :
# ice_age_df$species <- as.factor(ice_age_df$species)

# V√©rifions encore une fois la structure de l'objet :
# str(ice_age_df)

```

C'est maintenant √† vous de transformer la colonne `name` de
`ice_age_df`en facteur !

## Le r√©p√©rtoire de travail

::: {.callout-important title="Important"}
Dans R, le **r√©pertoire de travail** (angl. *working directory*) fait
r√©f√©rence au dossier de votre ordinateur dans lequel R lit et enregistre
les fichiers par d√©faut. Il s'agit d'un concept crucial dans la
programmation R, car il d√©termine l'endroit o√π R recherche les fichiers
√† lire et l'endroit o√π il place les fichiers lorsque vous les
enregistrez.
:::

Vous pouvez d√©finir votre r√©pertoire de travail avec la fonction
**`setwd()`**.

Une possibilit√©, c'est de le faire manuellement dans le volet *output*
en bas √† droite :

1.  Naviguez sur l'onglet **Files**
2.  Cliquez sur les trois petits points **...** tout √† droite
3.  Choisissez un dossier sur votre ordinateur qui peut servir de
    r√©pertoire de travail (vous devez peut-√™tre en cr√©er un d'abord et
    lui donner un nom utile, p.ex. "ex_meth_sp24"
4.  Cliquez ensuite sur la petite **roue bleue** (More) et choisissez
    **Set as Working Directory**
5.  Vous pouvez ensuite copier et coller le code R qui d√©finit le
    r√©pertoire de travail depuis l'onglet de la console et l'inclure
    dans votre script R

Sur l'ordinateur de l'enseignant, ce code est le suivant :
`setwd("C:/Users/julim/switchdrive/001_Exercices_Methodes_2_SP_22/R")`
**Attention** : Ce code ne marche naturellement pas sur votre machine.
Il faut l'adapter et inclure un chemin de fichier de votre ordinateur.

Vous pouvez ensuite v√©rifier si le r√©pertoire de travail a √©t√©
correctement d√©fini avec la fonction `getwd()`

### Devoir pour Session 3 (Problem Set 1)

-   **Problem Set 1**

    -   Le Problem Set 1 est un QCM sur Moodle qui sera accessible
        pendant les 30 premi√®res minutes de l'exercice.

    -   Assurez-vous que R et RStudio fonctionnent sur votre ordinateur
        portable et qu'il a suffisamment de batterie. Il est de votre
        responsabilit√© de vous en assurer.

    -   Dans le Problem Set 1, il y a √† la fois des questions que vous
        devez r√©soudre avec du code R et des questions de compr√©hension
        qui peuvent √™tre r√©solues sans code. Vous devez donc √™tre
        capable non seulement d'ex√©cuter le code, mais aussi d'en
        comprendre l'objectif.

    -   R√©p√©tez le contenu des sessions 1 et 2 sur votre ordinateur afin
        de bien vous pr√©parer pour le Problem Set 1.

    -   Assurez-vous que toutes les parties du code fonctionnent sans
        message d'erreur.

-   **Attention** :

    -   Vous devez tous venir la semaine prochaine dans le groupe dans
        lequel vous √™tes inscrits via my.unifr (A, B, C, D) si vous
        voulez participer au Problem Set 1.

    -   Chaque √©tudiant-e n'aura acc√®s qu'au Problem Set 1 de son
        groupe.

    -   Les personnes qui ne sont inscrites dans aucun groupe ne peuvent
        pas valider le Problem Set 1.

{{< pagebreak >}}

# Session 3 (Problem Set 1)

Les r√©sultats du **Problem Set 1** (bonnes r√©ponses, √©chelle des notes)
sont accessibles sur la page Moodle de l'exercice.

Voici l'histogramme des points obtenus par n = 62 √©tudiant-e-s qui ont
particip√© au Problem Set 1.

-   Le nombre maximal de points √©tait de 20, il fallait 10 pour passer
    le test.

-   La moyenne des points obtenus √©tait de 14.2 points (note = 4.75).

-   59 √©tudiant-e-s ont r√©ussi Problem Set 1 (95%).

```{r}
#| echo: false
#| output: true
#| warning: false
# script pour faire un histogramme des points obtenus dans le Problem Set 1
# cours : Exercices M√©thodes II
# date : 5/6 mars 2025
# auteur : Julian Maitra

library(ggplot2)

# Adaptez le code suivant pour votre r√©pertoire de travail :

setwd("/Users/domus_julian/Documents/GitHub/intro-a-R/code")

# Enregistrez le fichier CSV points_ps_1 dans votre r√©pertoire de travail, 
# puis importez les donn√©es dans R (modifiez le code suivant selon votre ordinateur) :

points_ps_1 <- read.csv("~/Documents/GitHub/intro-a-R/code/points_PS_1.csv", encoding="UTF-8")

#points_ps_1 # il y a 62 observations de trois variables : etudiant-e, groupe et points

hist_ps_1 <-ggplot(points_ps_1, 
                   aes(x=points)) + 
  geom_histogram(binwidth = 1, color="black", fill="white") +
  labs(title = "Histogramme des points obtenus dans le PS 1", # labs() permet de d√©finir plusieurs labels en m√™me temps (titre, axes, etc.)
       subtitle = "n = 62 r√©sultats de test", 
       caption = "Source des donn√©es : Moodle") +       
  xlab("Points obtenus") +                             
  ylab("Fr√©quence") +
  theme_minimal() +
  coord_cartesian(xlim = c(0,20), ylim = c(0,14)) +
  scale_x_continuous(breaks = seq(0,20, by=1)) +
   scale_y_continuous(breaks = seq(0,14, by=2)) +
  geom_vline(aes(xintercept=9.5),
             color="red",  linewidth=1, linetype="dashed")
hist_ps_1
```

{{< pagebreak >}}

# Session 4 \| Paquets R, jeux de donn√©es int√©gr√©s, visualisations I

La session 4 a pour but d'introduire trois √©l√©ments fondamentaux en
analyse de donn√©es avec R :

1.  Installer et charger des **paquets R** sur son ordinateur
2.  Utiliser des **jeux de donn√©es int√©gr√©s en R** pour s'entra√Æner en
    analyse de donn√©es
3.  Apprendre √† utiliser le paquet **ggplot2** pour cr√©er des
    visualisations de donn√©es

## Les paquets R

::: {.callout-note icon="true"}
## √Ä noter

Dans la programmation R, un **paquet** (angl. *package*) est un ensemble
de fonctions, de donn√©es et de code compil√© dans un format bien d√©fini.

Les paquets √©tendent les fonctionnalit√©s de R de base en fournissant des
outils suppl√©mentaires pour l'analyse des donn√©es, la visualisation,
l'apprentissage automatique, la mod√©lisation statistique et beaucoup
d'autres applications sp√©cialis√©es.

Les paquets R peuvent √™tre d√©velopp√©s par n'importe qui et partag√©s
gratuitement avec d'autres (open source). Par cons√©quent, une grande
multitude de paquets R sont disponibles.
:::

Notez que la plupart des paquets R doit √™tre install√© s√©par√©ment,
normalement depuis le site [Comprehensive R Archive Network
(CRAN)](http://cran.r-project.org). Dans ce cours, nous nous
concentrerons sur deux paquets c√©l√®bres :

-   `ggplot2` pour cr√©er des **visualisations de donn√©es**

-   `dplyr` pour **manipuler les jeux de donn√©es**

Tous deux font partie du [tidyverse](https://www.tidyverse.org), une
collection de paquets con√ßus pour la science des donn√©es. Nous
utiliserons √©galement le paquet suivant :

-   `ggthemes` pour **augmenter le design des graphiques**

Pour utiliser un paquet R sur votre ordinateur, il faut :

1.  D'abord **installer** le paquet en question avec la fonction
    `install.packages()`. Cela peut durer quelques minutes.
2.  Ensuite **activer** le paquet avec la fonction `library()`.

::: {.callout-tip title="Astuce"}
Dans RStudio, on peut aussi installer les paquets via l'onglet **Tools**
et le menu d√©roulant : Cliquez sur *Install Packages*... et cherchez les
paquets que vous voulez installer.
:::

Utilisez le code suivant pour installer les paquets R requis pour notre
cours. Enlevez les croisillons, √©x√©cutez le code avec
`install.packages()` puis r√©ajouter les croisillons pour √©viter de
r√©installer les paquets chaque fois que vous √©x√©cutez le code dans votre
script ! Activer ensuite les paquets avec `library()`.

```{r}
#| echo: true
#| output: false
# install.packages("tidyverse")
# install.packages("ggthemes")

library(tidyverse)
library(ggthemes)
```

√Ä noter : `ggplot2` et `dplyr` sont install√©s avec le `tidyverse`, il ne
faut donc plus les installer s√©par√©ment.

::: {.callout-important title="Important"}
Notez qu'une fois install√©, vous n'avez pas besoin de le r√©installer les
paquets √† chaque fois avec `install.packages()`. Cependant, vous devez
**activer** tous les paquets R que vous voulez utiliser dans une session
avec la commande `library()`. Sans activation, vous allez recevoir des
messages d'erreur.
:::

Certains paquets ont des documentations auxquelles vous pouvez acc√©der
gr√¢ce au point d'interrogation. Ces infos sont affich√©s dans le volet
*Output* sous l'onglet *Help*.

-   `?ggplot2`

-   `?dplyr`

En ligne, vous pouvez √©galement trouver de nombreuses ressources qui
expliquent en d√©tail les fonctionnalit√©s des diff√©rents paquets R et
vous renvoient vers d'autres livres, tutoriels, cours, etc., p. ex. :

-   [Documentation officielle de
    `ggplot2`](https://ggplot2.tidyverse.org/index.html)

-   [Documentation officielle de `dplyr`](https://dplyr.tidyverse.org)

-   [Exemples de graphiques cr√©es avec les diff√©rents designs de
    `ggthemes`](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/)

Vous pouvez v√©rifier quels paquets sont **actuellement install√©s sur
votre ordinateur** avec la fonction `installed.packages()` (vous pouvez
laisser vide l'espace entre parenth√®ses) :

```{r}
#| echo: true
#| output: false
installed.packages()
```

## Les jeux de donn√©es int√©gr√©s

Une excellente fa√ßon, et probablement la plus efficace, d'apprendre √†
utiliser R pour l'analyse de donn√©es consiste √† travailler avec des
**jeux de donn√©es int√©gr√©s dans R**.

Ces jeux de donn√©es exemplaires pr√©sentent deux avantages principaux.

1.  Il est facile d'y acc√©der et de les charger dans votre session
    RStudio, car ils sont int√©gr√©s √† R et √† certains de ses paquets.

Cela les distingue fortement des donn√©es du "monde r√©el", comme les
donn√©es de questionnaires ou de m√©dias sociaux, qu'il faut souvent
d'abord nettoyer et formater, puis importer dans RStudio sous forme de
fichiers externes. Avec les jeux de donn√©es int√©gr√©s, vous pouvez
imm√©diatement commencer l'analyse et la visualisation des donn√©es.

2.  Ces jeux de donn√©es ont prouv√© leur utilit√© dans d'innombrables
    supports d'apprentissage.

Par cons√©quent, vous pouvez facilement trouver des ressources
suppl√©mentaires et des exemples de code √† leur sujet.

Dans ce qui suit, nous allons explorer quatre jeux de donn√©es classiques
de ce type :

-   `iris`

-   `mtcars`

-   `diamonds`

-   `palmerpenguins`

::: {.callout-tip title="Astuce"}
Vous pouvez afficher les jeux de donn√©es qui sont actuellement
acc√©ssible sur votre ordinateur avec la commande `data().`
:::

### le jeu de donn√©es `iris`

Le jeu de donn√©es `iris` est un ensemble de donn√©es c√©l√®bre qui contient
les mesures en centim√®tres des variables longueur et largeur du s√©pale,
ainsi que longueur et largeur du p√©tale, pour trois exp√®ces de fleurs
d'iris (Setosa, Virginica et Versicolor). Il y a 150 observations en
total (50 pour chaque esp√®ce).

Le jeu de donn√©es a √©t√© rendu c√©l√®bre par le statisticien et biologiste
britannique **Ronald Fisher** dans un article scientifique de 1936 qui
avait beaucoup d'influence dans le domaine des statistiques. Les donn√©es
d'iris eux-m√™me ont √©t√© r√©colt√© par le botaniste Edgar Anderson en 1935
sur la p√©ninsule de Gasp√©sie au Qu√©b√©c, Canada.

::: {.callout-caution collapse="true"}
## Plus sur Ronald Fisher

Ronald Fisher (1890-1962) √©tait un statisticien, g√©n√©ticien et
biologiste britannique qui a jou√© un r√¥le crucial dans le d√©veloppement
de la science statistique moderne. Il est connu pour son travail dans le
d√©veloppement des fondements des m√©thodes statistiques, incluant
l'analyse de variance (ANOVA), le test exact de Fisher et l'estimation
du maximum likelihood. Fisher a √©galement apport√© des contributions
significatives en g√©n√©tique, o√π son travail sur la th√©orie de la
s√©lection naturelle et la g√©n√©tique des populations a aid√© √† combler le
foss√© entre la g√©n√©tique mend√©lienne et l'√©volution darwinienne. Il est
consid√©r√© comme l'un des architectes principaux de la synth√®se
n√©o-darwinienne. Son influence s'√©tend au-del√† de la statistique et de
la g√©n√©tique aux domaines plus larges de la biologie et de la recherche
agricole, faisant de lui une figure pivotale de la science du 20e
si√®cle.
:::

<a title="Diego Mariano, CC BY-SA 4.0 &lt;https://creativecommons.org/licenses/by-sa/4.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Flores_de_%C3%8Dris.png"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/Flores_de_%C3%8Dris.png/512px-Flores_de_%C3%8Dris.png" alt="Flores de √çris" width="512"/></a>

Il y a des statistiques sur trois esp√®ces d'iris dans le jeu de donn√©es
[Source :
wikimedia.org](https://commons.wikimedia.org/wiki/File:Flores_de_√çris.png)

Dans l'apprentissage de R, ce jeu de donn√©es est souvent utilis√© pour
illustrer diverses techniques d'analyse de donn√©es, y compris le
clustering, la classification et la visualisation.

Explorons un peu le jeu de donn√©es `iris` avec du code !

```{r}
#| echo: true
#| output: false

dim(iris) # Ceci affiche le nombre de lignes et de colonnes)

head(iris) # Affiche les six premi√®res lignes

str(iris) # Informations sur la structure du jeu de donn√©es

names(iris) # Affiche les noms des colonnes
```

Regardons ce que √ßa donne apr√®s l'√©x√©cution de chaque ligne de code :

```{r}
#| echo: true
#| output: true

dim(iris) 

head(iris) 

str(iris) 

names(iris) 
```

::: {.callout-tip title="Astuce"}
Vous pouvez consulter la documentation pour beaucoup de jeux de donn√©es
avec un point d'interrogation : `?iris()`.
:::

### le jeu de donn√©es `mtcars`

Utilisez le script suivant pour analyser `mtcars`(lisez √©galement la
documentation avec `?mtcars`) !

```{r}
#| warning: false
#| echo: true
#| output: false

# Chargez le jeu de donn√©es mtcars. Il devrait appara√Ætre dans l'environnement
data(mtcars)

# Affichez mtcars
mtcars

# vous pouvez explorer mtcars manuellement en double cliquant dessus dans l'environnement

# Affichez seulement les six premi√®res observations
head(mtcars)

# Affichez seulement les six derni√®res observations
tail(mtcars)

# Appliquez quelques autres commandes pour explorer ce jeu de donn√©es
class(mtcars)
dim(mtcars)

str(mtcars)
summary(mtcars)

glimpse(mtcars) # cette commande marche seulement si vous avez activ√© le tidyverse

# Extraire la colonne mpg ("miles per gallon") avec le signe $
# et calculer la moyenne, la m√©dianne, le minimum et le maximum

mtcars$mpg

mean(mtcars$mpg)

median(mtcars$mpg)

min(mtcars$mpg)

max(mtcars$mpg)
```

<a title="Jeremy from Sydney, Australia, CC BY 2.0 &lt;https://creativecommons.org/licenses/by/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:1974_Toyota_Corolla_(KE20)_L_2-door_sedan_(20538771443).jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/1974_Toyota_Corolla_%28KE20%29_L_2-door_sedan_%2820538771443%29.jpg/512px-1974_Toyota_Corolla_%28KE20%29_L_2-door_sedan_%2820538771443%29.jpg" alt="1974 Toyota Corolla (KE20) L 2-door sedan (20538771443)" width="512"/></a>

Un des mod√®les de mtcars : Le Toyota Corolla de 1974. [Source :
wikimedia.org](https://commons.wikimedia.org/wiki/File:1974_Toyota_Corolla_(KE20)_L_2-door_sedan_(20538771443).jpg)

### le jeu de donn√©es `diamonds`

C'est maintenant √† vous d'explorer ce jeu de donn√©es avec du code !

Utilisez √©galement `?diamonds()` !

<a title="Jerry Cone, Public domain, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Diamond-1128734.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1d/Diamond-1128734.jpg/512px-Diamond-1128734.jpg" alt="Diamond-1128734" width="512"/></a>

Qu'est-ce qui d√©finit le prix d'un diamant ? [Source :
wikimedia.org](https://commons.wikimedia.org/wiki/File:Diamond-1128734.jpg)

## Introduction aux visualisations avec `ggplot2`

::: {.callout-note icon="true"}
## √Ä noter

`ggplot2`, qui fait partie du `tidyverse`, est un paquet de
visualisation de donn√©es tr√®s populaire dans R. Il a √©t√© con√ßu pour
faciliter la cr√©ation de graphiques complexes et multicouches avec une
syntaxe coh√©rente et consistante nomm√©e *grammar of graphics*.

*ggplot2* est donc un acronyme form√© √† partir des mots *grammar of
graphics plots* (fran√ßais : *grammaire des graphiques*). Le "2" dans
ggplot2 indique simplement la deuxi√®me g√©n√©ration de ce paquet R.

Avec `ggplot2`, les utilisateurs peuvent construire des graphiques de
mani√®re incr√©mentale en ajoutant des couches, ce qui le rend flexible
pour une large gamme de besoins graphiques. Cela permet de cr√©er des
visualisations hautement personnalisables et esth√©tiquement attrayantes,
allant de simples diagrammes de dispersion √† des figures multi-panneaux
complexes.
:::

Le tableau suivant d√©crit les couches d'un graphique ggplot :

| Couche | D√©scription/Variables | Obligatoire ? |
|------------------------|:-----------------------|:----------------------:|
| *data* | le jeu de donn√©es que nous voulons visualiser | oui |
| *aesthetics* | le *mapping* de nos variables : axes *x* et *y*, *color*, *fill*, *alpha*, *line width*, etc. | oui |
| *geometries* | le type visuel du graphique : *point*, *line*, *histogram*, *bar*, *boxplot* | oui |
| *themes* | Le design du graphique | non |
| Autres couches optionelles : *facets*, *statistics*, *coordinates* | Pour des visualisations plus complexes | non |

: Les couches d'un graphique ggplot

Pour comprendre comment cela fonctionne, voici un exemple de code dans
lequel les diff√©rentes couches d'un graphique *ggplot* sont ajout√©es
√©tape par √©tape dans la fonction `ggplot()`. (Normalement, nous ne
proc√©derions pas ainsi, mais utiliserions directement le code en entier
pour cr√©er le graphique).

Le but dans cet exemple est de visualiser le jeu de donn√©es `diamonds`
pour comprendre la relation entre les variables `price` (prix) et
`carat` (poids) des diamants dans le jeu de donn√©es !

::: {.callout-note icon="true"}
## √Ä noter

Important : avant d'analyser un ensemble de donn√©es, il faut toujours
acqu√©rir des **connaissances contextuelles** sur ce que les donn√©es
repr√©sentent.

Dans notre exemple, il s'agit de diamants. Dans le monde des diamants,
il est important de comprendre qu'il existe **quatre crit√®res de
qualit√©** qui d√©terminent **la valeur** (donc le prix) d'un diamant. Ce
sont les suivants :

-   La taille (angl. *cut*)

-   La puret√© (*clarity*)

-   La couleur (*color*)

-   Le poids en carats (*carat*)

En anglais, on parle donc aussi des 4C. Le jeu de donn√©es `diamonds`
contient pr√©cis√©ment ces variables.
:::

```{r}
# La premi√®re couche, data, d√©finit le jeu de donn√©es
ggplot(data = diamonds)
```

Notre graphique n'est pour l'instant qu'une zone grise ! Catastrophe ?
Bien s√ªr que non üòÄ. Nous devons maintenant d√©finir les autres
param√®tres de la fonction `ggplot()` !

```{r}
# La deuxi√®me couche, aesthetics, d√©finit le mapping de nos variables sur les axes y et x
ggplot(data = diamonds,
       mapping = aes(x = carat, y = price))
```

La zone grise a maintenant re√ßu des unit√©s pour ses axes x (`carat`) et
y (`price`). Mais il n'y a toujours pas de donn√©es affich√©es !

```{r}
# La troisi√®me couche, geometries, d√©finit le type visuel de notre graphique
ggplot(data = diamonds,
       mapping = aes(x = carat, y = price)) +
  geom_point()
```

Ouf, si vous avez ex√©cut√© le dernier code, vous avez maintenant 53 940
points de donn√©es affich√©es dans votre graphique ! Car il y a tant
d'observations dans le jeu de donn√©es `diamonds`.

Bon courage si vous avez un vieil ordinateur, cela peut prendre un
certain temps avant que R ne produise le graphique...

Mais jetons un coup d'≈ìil au graphique. Qu'est-ce qui saute aux yeux,
pouvez-vous d√©j√† identifier des tendances ?

```{r}
# On peut maintenant encore optimiser notre graphique
ggplot(data = diamonds,
       mapping = aes(x = carat, y = price, color = clarity)) +
  geom_point()
```

Vous avez remarqu√© ce qui a chang√© dans le code ?

```{r}
# Ajoutons encore une couche optionnelle mais utile au graphique : labs() nous permet d'ajouter et de personnaliser des titres, sout-titres, titre d'axes, titres de l√©gendes, etc. ! 
ggplot(data = diamonds,
       mapping = aes(x = carat, y = price, color = clarity)) +
  geom_point() + 
  labs(title = "La relation entre prix et carat des diamants",
    subtitle = "n = 53 940 diamants",
    y = "Prix", 
    x = "Carat", 
    colour = "Puret√©")
```

Maintenant il s'agit d'interpr√©ter le graphique. Que nous dit-il sur la
relation entre prix et carats des diamants ? Quel r√¥le joue la variable
*puret√©* (`clarity`)?

### Devoir pour Session 5

-   Ex√©cutez toutes les sections de code de la session 4 sur votre
    ordinateur.

-   Entra√Ænez-vous √† ouvrir un nouveau script R, √† d√©finir un r√©pertoire
    de travail et √† enregistrer le script dans un dossier sur votre
    ordinateur.

-   Assurez-vous que le paquet R `tidyverse` est install√© correctement
    sur votre ordinateur.

-   Utilisez le code R de mani√®re autonome pour explorer le jeu de
    donn√©es `diamonds`. Vous devez √™tre en mesure de comprendre et
    d'expliquer comment il est structur√© (nombre d'observations n, unit√©
    statistique, variables, origine des donn√©es, etc).

{{< pagebreak >}}

# Session 5 \| Visualisations II

La session 5 a pour but d'approfondir les techniques de visualisation de
donn√©es avec le paquet `ggplot2`, notamment la cr√©ation des types de
graphique suivants :

1.  Les nuages de points (angl. *scatter plots*)
2.  Les diagrammes √† barres (angl. *bar plots*)
3.  Les histogrammes (angl. *histograms*)
4.  Les bo√Ætes √† moustaches (angl. *box plots*)

```{r}
#| warning: false
# N'oubliez pas de charger les paquets tidyverse et ggthemes !
# Ex√©cutez le code suivant pour le faire :
library(tidyverse)
library(ggthemes)
```

## 1. Les nuages de points (angl. *scatter plots*)

Commen√ßons par le **nuage de points**, que nous avons d√©j√† vu lors de la
derni√®re session, lorsque nous avons visualis√© la relation entre les
carats et les prix dans le jeu de donn√©es `diamonds`.

::: {.callout-note icon="true"}
## √Ä noter

Un **nuage de points** (aussi appel√© diagramme de dispersion) est
utilis√© dans `ggplot2` pour repr√©senter les valeurs de **deux variables
num√©riques diff√©rentes** par des points, avec une variable sur l'axe des
X et l'autre sur l'axe des Y.

Ce type de graphique est id√©al pour l'analyse exploratoire de donn√©es,
permettant d'observer les relations entre les variables, de d√©tecter des
tendances, des regroupements, des valeurs √™xtremes (angl. *outliers*) ou
de v√©rifier des hypoth√®ses de corr√©lation.

Dans la fonction `ggplot()`, un scatter plot est cr√©√© avec la couche
g√©om√©trique `geom_point()`.
:::

Cr√©ons un nuage de points avec le jeu de donn√©es `iris`, en comparant
les longueurs et les largeurs des s√©pales des iris (les variables
`Sepal.Length` et `Sepal.Width`).

Notez que, dans le code suivant, nous ne cr√©ons pas directement un
graphique `ggplot` mais nous stockons le graphique comme un objet dans
l'environnement, nomm√© `p1`, que nous pouvons ensuite afficher avec la
fonction `print()`. Nous verrons dans un instant pourquoi cette pratique
est utile.

```{r}
# nuage de points basique pour comparer la longueur et la largeur des s√©pales des iris
np1 <- ggplot(data = iris, 
               mapping = aes(x=Sepal.Length, y=Sepal.Width)) +
  geom_point() +
  labs(title = "Sepal length and width in the iris dataset")

print(np1)
```

Nous pouvons ajouter des couches √† l'objet `np1` sans l'√©craser, p. ex.
une ligne de r√©gression lin√©aire avec `geom_smooth(method = lm)` :

```{r}
#| warning: false
np1 + geom_smooth(method = lm)
```

Que nous indique la ligne de r√©gression ? En principe, elle indique une
correlation l√©g√®rement n√©gative entre les variables `Sepal.Length`et
`Sepal.Width` ! (la zone grise autour de la ligne bleue indique une
marge d'erreur).

Cela signifie que les iris dont les s√©pales sont plus longs ont tendance
√† avoir des s√©pales un peu moins larges ! Gardez cette constatation √†
l'esprit pour les √©tapes de codage suivantes.

```{r}
# Ecrasons np1 en changeant un peu le code. D√©couvrez vous-m√™me ce qui a chang√© dans le code !
np1 <- ggplot(iris, 
               aes(x=Sepal.Length, y=Sepal.Width, color = Species)) +
  geom_point() +
  labs(title = "Sepal length and width in the iris dataset")

print(np1)
```

Vous pouvez voir dans le graphique que nous pouvons maintenant
diff√©rencier les trois esp√®ces d'iris. La dispersion des points semble
moins al√©atoire, ce qui permet de voir des groupes de points appartenant
√† l'une ou l'autre esp√®ce (angl. *cluster*).

Maintenant, ajoutons √† nouveau une couche `geom_smooth()` √† l'objet
`np1` !

```{r}
#| warning: false
np1 + geom_smooth(method = lm)
```

Les trois lignes de r√©gression (une pour chaque type d'iris) montrent
maintenant un tout autre r√©sultat : en effet, la corr√©lation entre
`Sepal.Length` et `Sepal.Width` est clairement positive.

Cette constatation est un exemple d'analyse exploratoire des donn√©es,
rendue possible par les possibilit√©s de visualisation de `ggplot2`.

## 2. Les diagrammes √† barres

::: {.callout-note icon="true"}
## √Ä noter

Les **diagrammes √† barres** dans R avec `ggplot2` sont utilis√©s pour
repr√©senter visuellement des **donn√©es cat√©gorielles**, permettant de
comparer des quantit√©s entre diff√©rentes cat√©gories.

On les utilise donc souvent pour montrer la fr√©quence ou la proportion
d'observations dans chaque cat√©gorie, ce qui les rend utiles pour
analyser des tendances ou des diff√©rences au sein de donn√©es
cat√©gorielles.

Dans la fonction `ggplot()`, un diagramme √† barres est cr√©√© avec la
couche g√©om√©trique `geom_bar()`.
:::

Par exemple, nous pouvons utiliser le code simple suivant pour comparer
la fr√©quence des diff√©rentes tailles (angl. `cut`) dans le jeu de
donn√©es `diamonds`. Cette-fois ci, nous sauvegardons et nommons le
graphique `db1`.

```{r}
db1 <- ggplot(data = diamonds, 
       mapping = aes(x = cut)) + 
        geom_bar()

print(db1)
```

Am√©liorons le graphique avec des param√®tres et des couches
suppl√©mentaires de la fonction `ggplot()` (Notez que nous allons
simplement √©craser l'objet `db1` cr√©√© pr√©c√©demment avec une nouvelle
version de `db1` !) :

```{r}
library(ggthemes)

db1 <- ggplot(data = diamonds, 
       mapping = aes(x = cut, fill = cut)) + 
        geom_bar() +
        labs(title = "Frequency of cut quality types in the diamonds dataset",
             subtitle = "n = 53,940 diamonds",
             x = "Cut Quality", y = "Count") +
        theme_minimal()

print(db1)
```

Que nous dit le graphique ? Il est int√©ressant de constater que dans le
jeu de donn√©es `diamonds`, le niveau de qualit√© le plus √©lev√© de la
taille, √† savoir `ideal`, est √©galement le plus fr√©quent.

::: {.callout-caution collapse="false"}
## Attention

Dans la fonction `ggplot()`, il y a une diff√©rence si vous voulez
ajouter de la couleur aux points (qui ont math√©matiquement z√©ro
dimension) ou aux surfaces (qui ont deux dimensions), comme dans les
diagrammes √† barres.

Si vous voulez ajouter de la couleur √† une surface, vous devez utiliser
l'argument `fill = "xyz"`. L'argument `color = "xyz"` que nous avons
utilis√© pour ajouter de la couleur aux nuages de points ne fera
qu'ajouter de la couleur √† la ligne autour de la surface !
:::

### C'est maintenant √† vous de jouer !

Reprenez le code que nous avons utilis√© pour cr√©er `db1` et modifiez-le
pour cr√©er un nouvel objet,`db2`, qui visualise la fr√©quence des types
de qualit√© de couleur (`color`) dans le jeu de donn√©es `diamonds` sous
la forme d'un diagramme √† barres !

## 3. Les histogrammes

::: {.callout-note icon="true"}
## √Ä noter

Un **histogramme** est un type de graphique utilis√© pour repr√©senter
**la distribution** d'**une variable num√©rique** √† travers des barres.

Un "histogramme s√©pare les valeurs possibles des donn√©es en classes ou
groupes. Pour chaque groupe, on construit un rectangle dont la base
correspond aux valeurs de ce groupe et la hauteur correspond au nombre
d'observations dans le groupe.

L‚Äôhistogramme a une apparence semblable au graphique √† barres
verticales, mais il n'y a pas d'√©cart entre les barres.

En r√®gle g√©n√©rale, l'histogramme poss√®de des barres d'une largeur √©gale"
(Source : [Statistique Canada,
2021).](https://www150.statcan.gc.ca/n1/edu/power-pouvoir/ch9/histo/5214822-fra.htm)

L'histogramme est particuli√®rement utile pour :

-   **Analyser la distribution** : Comprendre si les donn√©es sont
    normalement distribu√©es, asymm√©triques (angl. *skewness*), ou si
    elles pr√©sentent un plateau (kurtosis).
-   **D√©tecter les valeurs extr√™mes** : Identifier les donn√©es qui
    s'√©cartent du reste de l'ensemble des donn√©es de mani√®re
    signifiante.
-   **Comparer des distributions** : Observer comment diff√©rentes
    sous-populations se comparent les unes aux autres en termes de
    distribution de donn√©es.

Avec `ggplot2` en R, cr√©er un histogramme se fait avec la couche
g√©ometrique `geom_histogram()`. `ggplot2` calcule automatiquement la
taille des intervalles (angl. *bins*) par d√©faut, mais cela peut √™tre
ajust√© manuellement en sp√©cifiant l'argument `binwidth = xyz`dans la
fonction `geom_histogram()`, p. ex. `geom_histogram(binwidth = 30)`.
:::

Avant de cr√©er un histogramme avec le code R, introduisons d'abord une
nouvelle fonction : `rnorm()`. Elle peut √™tre utilis√©e pour cr√©er des
valeurs al√©atoires qui suivent une **loi normale** (angl. *normal
distribution*).

Les arguments que nous pouvons entrer dans la fonction sont :

-   le nombre `n` de valeurs al√©atoires que nous voulons cr√©er

-   la moyenne `mean` de la distribution des valeurs al√©atoires

-   l'√©cart-type `sd` de la distribution des valeurs al√©atoires

Notez que par d√©faut, la fonction utilise `mean = 0` et `sd = 1`, ce qui
correspond √† une **loi normale centr√©e r√©duite** (angl. *standard normal
distribution*).

Utilisez aussi `?rnorm()`pour acc√©der √† plus d'infos.

::: {.callout-tip title="Astuce"}
La fonction `set.seed()` dans R est utilis√©e pour d√©finir la graine
(seed en anglais) du g√©n√©rateur de nombres al√©atoires. La graine est un
nombre entier qui sert de point de d√©part pour le g√©n√©rateur de nombres
al√©atoires.

En d√©finissant une graine sp√©cifique, par exemple avec `set.seed(123)`,
vous garantissez que la s√©quence de nombres al√©atoires g√©n√©r√©e par la
suite avec des fonctions telles que `rnorm()`, sera la m√™me √† chaque
fois que vous ex√©cuterez le code, ce qui est utile pour la
reproductibilit√© des r√©sultats.
:::

Dans le code R suivant, nous utilisons `rnorm()` pour simuler les
distributions des tailles des hommes et des femmes en Suisse.

Selon un article de [*24
heures*](https://www.24heures.ch/calculateur-en-ligne-quelle-taille-faites-vous-par-rapport-aux-autres-191558705635#),
en Suisse, les femmes ont une taille moyenne de 164.7 cm tandis que les
hommes mesurent 177.4 cm en moyenne. Dans la suite, nous supposons que
les √©carts-types sont de +- 5.6 cm pour les femmes et de +- 6.1 cm pour
les hommes.

```{r}
#| warning: false
# Simulation de tailles de femmes en Suisse
# Cr√©er 500 valeurs al√©atoires de taille 
# (moyenne = 164.7 et √©cart-type = 5.6) avec la fonction rnorm().
set.seed(123)

taille_f <- rnorm(500, mean = 164.7, sd = 5.6)

head(taille_f)

# stocker taille_f comme objet de type "data.frame"
taille_f <- as.data.frame(taille_f)

# visualiser taille_f avec un histogramme basique
ggplot(data = taille_f, 
       mapping = aes(x=taille_f)) +
  geom_histogram()

# jouer avec le param√®tre "binwidth" de l'histogramme 
# qui d√©finit l'intervalle de la base de ses barres
ggplot(data = taille_f, 
       mapping = aes(x=taille_f)) +
  geom_histogram(binwidth = 10)

ggplot(data = taille_f, 
       mapping = aes(x=taille_f)) +
  geom_histogram(binwidth = 0.1)

ggplot(data = taille_f, 
       mapping = aes(x=taille_f)) +
  geom_histogram(binwidth = 1)

# stocker l'histogramme comme objet, nomm√© hist1, et modifier sa couleur
hist1 <- ggplot(data = taille_f, 
                 mapping = aes(x=taille_f)) +
  geom_histogram(binwidth = 1, color = "black", fill = "white")

print(hist1)

# Ajouter des couches suppl√©mentaires pour am√©liorer la visualisation
# p. ex. des titres
hist1 <- hist1 + labs(title = "Histogramme des tailles de femmes en Suisse",
                        subtitle = "Simulation bas√©e sur 500 observations",
                        x = "Taille en cm",
                        y = "Fr√©quence") +
        theme_bw()

print(hist1)
```

::: {.callout-tip title="Astuce"}
Un √©l√©ment cl√© des visualisations de donn√©es est la **couleur**. Le
document PDF suivant, cr√©√© par Ying Wei de l'Universit√© de Columbia √†
New York, montre et liste les noms des couleurs dans R. Vous pouvez
copier-coller le nom d'une couleur et l'utiliser dans votre graphique
ggplot2 !

-   [Colors in R](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)
:::

### C'est maintenant √† vous de jouer !

Reprenez le code que nous avons utilis√© pour cr√©er `taille_f` et `hist1`
et modifiez-le pour cr√©er une nouvelle simulation de taille d'hommes,
`taille_h`, et un nouveau histogramme qui montre sa distribution,
`hist2`. Jouez avec les param√®tres `binwidth`et la couleur de votre
visualisation. Pour cette t√¢che, vous pouvez supposer que les hommes en
Suisse ont une taille moyenne (`mean`) de 177,4 cm avec un √©cart-type
(`sd`) de 6,1 cm.

## 4. Les bo√Ætes √† moustaches (angl. *boxplots*)

::: {.callout-note icon="true"}
## √Ä noter

Les **bo√Ætes √† moustaches**, ou **boxplots**, sont un type de graphique
pour repr√©senter la distribution d'un ensemble de donn√©es √† travers cinq
mesures cl√©s :

1.  le minimum (d√©but de la "moustache" ou point extr√™me de minimum)
2.  le premier quartile (Q1 ; d√©but de la bo√Æte)
3.  la m√©diane (Q2 ; ligne qui "coupe la bo√Æte en deux")
4.  le troisi√®me quartile (Q3 ; fin de la bo√Æte) et
5.  le maximum (fin de la moustache ou point extr√™me de maximum)

Ces diagrammes permettent d'identifier rapidement la m√©diane, l'√©tendue
interquartile (angl. *interquartile range* = *IQR*) et les valeurs
√™xtremes potentielles. Ils sont particuli√®rement utiles pour comparer
les distributions entre plusieurs groupes ou variables.
:::

```{r}
#| warning: false
#| echo: false
#| output: true
# Sample data creation
# Replace this with your actual dataframe and column name for the numerical values
set.seed(1238)
df <- data.frame(value = rnorm(300, mean = 5, sd = 2))

# Calculating summary statistics for annotations
summaries <- df %>% 
  summarise(
    Min = min(value),
    Q1 = quantile(value, 0.25),
    Median = median(value),
    Q3 = quantile(value, 0.75),
    Max = max(value),
    IQR = IQR(value)
  ) %>% 
  mutate(
    LowerWhisker = pmax(Q1 - 1.5 * IQR, Min),
    UpperWhisker = pmin(Q3 + 1.5 * IQR, Max)
  )

# Creating the boxplot with annotations
p <- ggplot(df, aes(x = factor(1), y = value)) +
  geom_boxplot() +
  geom_text(data = summaries, aes(x = 1.4, y = Q1, label = paste("Q1 :", round(Q1, 2))), hjust = -0.1) +
  geom_text(data = summaries, aes(x = 1.4, y = Median, label = paste("M√©diane :", round(Median, 2))), hjust = -0.1) +
  geom_text(data = summaries, aes(x = 1.4, y = Q3, label = paste("Q3 :", round(Q3, 2))), hjust = -0.1) +
  geom_text(data = summaries, aes(x = 1.0, y = LowerWhisker, label = paste("Minimum (valeur ext√™me) :", round(LowerWhisker, 2))), hjust = -0.3) +
  geom_text(data = summaries, aes(x = 1.0, y = UpperWhisker, label = paste("Maximum :", round(UpperWhisker, 2))), hjust = -0.3) +
  scale_x_discrete(labels = NULL) + # Hide x-axis labels
  theme_minimal() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  labs(title = "Bo√Æte √† moustache avec des valeurs al√©atoires",
       y = "valeur")


# Display the plot
print(p)
```

Le dataset `mtcars` en R, qui contient des donn√©es sur les
caract√©ristiques de diff√©rents mod√®les de voitures, peut √™tre utilis√©
pour illustrer l'utilisation de boxplots.

Par exemple, pour visualiser la distribution de la consommation de
carburant (`mpg`) des voitures en fonction du nombre de cylindres
(`cyl`), on peut utiliser le code suivant :

```{r}
# Avant de cr√©er le boxplot, v√©rifions d'abord la structure de mtcars :
str(mtcars)
```

Nous pouvons constater que la colonne `cyl` (cylindre) est stock√©e au
format num√©rique.

C'est un probl√®me, car nous voulons comparer la consommation de
carburant des voitures √† 4, 6 ou 8 cylindres. Nous devons traiter
chacune d'entre elles comme un sous-groupe distinct. Comment faire ?

```{r}
# Transformons donc cyl en facteur
mtcars$cyl <- as.factor(mtcars$cyl)

# Et maintenant nous pouvons construire notre boxplot
box1 <- ggplot(data = mtcars, 
          aes(x=cyl, y=mpg, fill = cyl)) + 
            geom_boxplot(alpha=0.2) + 
              labs(title = "Consommation de carburant (mpg) par nombre de cylindres dans mtcars", x = "Nombre de cylindres", y = "Miles per gallon (mpg)")
print(box1)
  
```

Ce code g√©n√®re un boxplot, `box1`, pour chaque groupe de cylindres dans
le dataset `mtcars`, permettant de comparer facilement la consommation
de carburant entre les voitures avec un diff√©rents nombres de cylindres.

::: {.callout-note icon="true"}
## √Ä noter

Le param√®tre `alpha = 0.2` √† l'int√©rieur de `geom_boxplot()` rend les
boxplots transparents. En g√©n√©ral, `alpha` peut √™tre compris entre 0
(totalement transparent) et 1 (non transparent). C'est un param√®tre
suppl√©mentaire qui permet de personnaliser votre graphique `ggplot2`.
:::

On voit dans le graphique des boxplots que dans `mtcars`, les voitures
avec des moteurs ayant plus de cylindres ont aussi tendance √† √™tre moins
efficaces en termes de consommation de carburant. Il existe toutefois
quelques intersections entre les groupes. C'est-√†-dire qu'il y a des
voitures √† 8 cylindres qui sont relativement efficaces en termes de
consommation de carburant, surpassant quelques voitures √† 6 cylindres,
par exemple.

### Devoir pour Session 6 (Problem Set 2)

-   **Problem Set 2**

    -   Comme le premier Problem Set, le Problem Set 2 est un QCM sur
        Moodle qui sera accessible pendant 30 minutes du cr√©neau horaire
        de votre groupe de l'exercice.

    -   Assurez-vous que R et RStudio fonctionnent sur votre ordinateur
        portable et qu'il a suffisamment de batterie. Il est de votre
        responsabilit√© de vous en assurer.

    -   Le Problem Set 2 concernera principalement le contenu des
        sessions 4 et 5.

    -   Les bases de R qui ont √©t√© trait√©es dans les premi√®res sessions,
        comme par exemple la cr√©ation et l'√©crasement d'objets avec
        l'op√©rateur d'affectation `<-`, sont toutefois requises, car la
        mati√®re se fonde sur ces bases. Veuillez combler vous-m√™me les
        √©ventuelles lacunes √† ce sujet.

-   **Annonce : Questionnaire**

    -   Nous allons √©valuer **un questionnaire sur votre comportement
        d'utilisation des m√©dias** avec R comme autre √©l√©ment important
        du cours.

    -   Le questionnaire est **anonyme** (m√™me pour l'enseignant) et
        peut √™tre rempli en ligne via LimeSurvey jusqu'au **lundi 31
        mars 2025 √† 23h59**.

    -   Tous les √©tudiant-e-s ont re√ßu un lien personnel d'invitation au
        questionnaire par e-mail (les r√©ponses seront anonymis√©es et
        m√©lang√©es par le logiciel, l'enseignant ne verra que si les
        personnes invit√©es ont r√©pondu au questionnaire avant la date
        limite).

    -   Chaque √©tudiant-e qui aura rempli le questionnaire dans les
        d√©lais recevra un **bonus de 2 points dans le Problem Set 4**
        (10% des points).

{{< pagebreak >}}

# Session 6 (Problem Set 2)

Les r√©sultats du **Problem Set 2** (bonnes r√©ponses, √©chelle des notes)
sont acc√©ssibles sur la page Moodle de l'exercice.

Voici l'histogramme des points obtenus par n = 65 √©tudiant-e-s qui ont
particip√© au Problem Set 2 le 26 et 27 mars 2025.

-   Le nombre maximal de points √©tait de 20, il fallait 10 pour passer
    le test.

-   La moyenne des points obtenus √©tait de 12.7 (note = 4.5).

-   56 √©tudiant-e-s (86%) ont r√©ussi Problem Set 2.

```{r}
#| echo: false
#| output: true
#| warning: false
# script pour faire un histogramme des points obtenus dans le Problem Set 2
# cours : Exercices M√©thodes II
# date : 27/28 mars 2024
# auteur : Julian Maitra

library(ggplot2)

# Adaptez le code suivant pour votre r√©pertoire de travail :

setwd("/Users/domus_julian/Documents/GitHub/intro-a-R/code")

# Enregistrez le fichier CSV points_ps_2 dans votre r√©pertoire de travail, 
# puis importez les donn√©es dans R (modifiez le code suivant selon votre ordinateur) :

points_ps_2 <- read.csv("~/Documents/GitHub/intro-a-R/code/points_ps_2.csv", encoding="UTF-8")

#points_ps_2 # il y a 65 observations de trois variables : etudiant-e, groupe et points

hist_ps_2 <-ggplot(points_ps_2, 
                   aes(x=points_ps_2)) + 
  geom_histogram(binwidth = 1, color="black", fill="white") +
  labs(title = "Histogramme des points obtenus dans le PS 2", # labs() permet de d√©finir plusieurs labels en m√™me temps (titre, axes, etc.)
       subtitle = "n = 65 r√©sultats de test", 
       caption = "Source des donn√©es : Moodle") +       
  xlab("Points obtenus") +                             
  ylab("Fr√©quence") + 
  theme_minimal() +
  coord_cartesian(xlim = c(0,20), ylim = c(0,14)) +
  scale_x_continuous(breaks = seq(0,20, by=1)) +
   scale_y_continuous(breaks = seq(0,14, by=2)) +
  geom_vline(aes(xintercept=9.5),
             color="red",  linewidth=1, linetype="dashed")
hist_ps_2
```

{{< pagebreak >}}

# Session 7 \| Manipuler les donn√©es I

**Sujet : Manipuler les donn√©es (partie 1)**

Le premier but de cette session est d'apprendre √† importer des donn√©es
dans RStudio √† partir de **fichiers CSV** et de les stocker en forme de
data frame (format tabulaire).

Le deuxi√®me but est de se familiariser avec `dplyr` (prononc√©
"dee-ply-er" en anglais), un paquet du `tidyverse` con√ßu pour manipuler
les donn√©es en forme de data frame.

Contrairement aux jeux de donn√©es int√©gr√©s √† R (tels que `diamonds`,
etc.), la plupart des jeux de donn√©es du monde r√©el n√©cessitent des
**transformations** avant de pouvoir √™tre analys√©s et visualis√©s. √Ä
cette fin, nous examinerons √©galement certaines transformations de types
de variables et un nouvel op√©rateur, le `%>%` (angl. "pipe"; trad.
fran√ß. "tuyau"), qui est tr√®s utile pour les manipulations de donn√©es.

## Lire des donn√©es auf format CSV dans RStudio

Par la suite, nous alons appliquer `dplyr` pour manipuler les donn√©es
d'un jeu de donn√©es concret : un fichier CSV nomm√© `igposts.csv`. Ce
fichier contient des posts Instagram de c√©l√©brit√©es qui ont re√ßu
beaucoup d'interactions d'utilisateurs. Pour cette application, il faut
d'abord charger ce jeu de donn√©es dans notre session RStudio en cours.

::: {.callout-note icon="true"}
## √Ä noter

Un fichier de type **CSV** (angl. comma-separated values) est un format
textuel simple pour sauvegarder des donn√©es en forme de tableau, c'est √†
dire avec des valeurs organis√© par lignes et colonnes et s√©par√©es par
virgules.

Le format CSV pr√©sente l'avantage d'√™tre assez l√©ger et compatible avec
tous les syst√®mes d'exploitation. En outre, il est utile pour stocker
des donn√©es quantitatives en sciences sociales, qui se pr√©sentent
souvent sous forme de tableaux.

Voici un exemple de format CSV simple :

nom, pr√©nom, √¢ge\
Leclerc, Antoine, 53\
Gomez, Hugo, 25\
Nguyen, Laetitia, 19\

Que nous pouvons afficher comme tableau (√† noter que la premi√®re ligne
d√©signe les noms des colonnes) :

| nom     | pr√©nom   | √¢ge |
|:--------|:---------|:---:|
| Leclerc | Antoine  | 53  |
| Gomez   | Hugo     | 25  |
| Nguyen  | Laetitia | 19  |
:::

Avant l'importation de fichier CSV dans RStudio (et comme d√©j√† vu pleins
de fois dans le cours üòâ), il faut d'abord charger les paquets
n√©cessaire avec `library()` et d√©finir son r√©p√©rtoire de travail (vous
devez adapter les param√®tres de `setwd()` pour qu'il marche sur votre
ordinateur) :

```{r}
library(tidyverse)
 
setwd("/Users/domus_julian/Documents/GitHub/intro-a-R/code")
 
```

Pour charger le jeu de donn√©es `igposts.csv` dans RStudio, vous pouvez
suivre le processus suivant :

1.  Vous t√©l√©chargez le fichier `igposts.csv` depuis le [site Moodle du
    cours](https://moodle.unifr.ch/course/section.php?id=410649) (voir
    mat√©riel de la 7e session).

2.  Stockez le fichier `igposts.csv` dans le dossier que vous avez
    d√©finit comme r√©p√©rtoire de travail.

3.  Ensuite, vous utilisez le menu int√©ractif dans RStudio : File -\>
    Import Dataset -\> From Text (base)... et choisissez `igposts.csv`.

4.  Une fen√™tre avec des param√®tre apparait, que vous pouvez remplir de
    la mani√®re suivante :

    ![](images/clipboard-2412941684.png)

    -   Explications des param√®tres :

        -   **Encoding = UTF-8** : Indique √† RStudio d'utiliser
            [l'encodage de caract√®res
            UTF-8](https://fr.wikipedia.org/wiki/UTF-8) (qui est un
            standard tr√®s r√©pandu), ce qui est important pour lire
            correctement toutes les lettres (notamment les caract√®res
            avec des accents : √©, √§, √™, etc.).

        -   **Heading = YES** : Indique √† RStudio que la premi√®re ligne
            du fichier CSV contient les noms des colonnes.

        -   **Separator = Comma** : Indique √† RStudio que les valeurs du
            tableau sont s√©par√©es par des virgules "," (attention,
            certains documents francophones utilisent le point-virgule
            ";" √† la place de la virgule, ce qu'il faudrait tenir en
            compte, si c'√©tait le cas).

        -   **Decimal = Period** : Indique √† RStudio que le point "."
            est utilis√© pour les d√©cimales (et non la virgule "," comme
            c'est souvent le cas dans les documents en fran√ßais).

        -   **na.strings = #N/A** : Indique √† RStudio que les cellules
            vides dans le tableau, c'est √† dire, les valeurs manquantes,
            sont d√©sign√©es par #N/A (cela peut √™tre diff√©rent dans
            d'autres fichiers CSV).

5.  Finalement, vous pouvez copier et coller le code qui appara√Æt dans
    la console dans votre script R pour facilement recharger le fichier
    CSV ult√©rieurement.

```{r}
# Par exemple, pour l'ordinateur de l'enseignant, ce code est le suivant : 

igposts <- read.csv("/Users/domus_julian/Documents/GitHub/intro-a-R/code/igposts.csv", encoding="UTF-8", na.strings="#N/A")
 
# Si tout a bien march√©, l'objet igposts devrait appara√Ætre dans votre environnement
# Nous pouvons afficher la structure de igposts pour une premi√®re impression :

str(igposts)
```

## Explorez votre jeu de donn√©es import√©

Cela nous montre qu'il s'agit d'un data frame avec 100 observations et
12 variables. Chaque ligne repr√©sente un post Instagram d'une c√©l√©brit√©
(unit√© statistique) et chaque colonnes une variable diff√©rente associ√© √†
ce post.

Notez que les variables sont soit de type textuel (chr = "character"; p.
ex. `Account`= le nom du compte Insta qui a publi√© le post), soit
num√©rique (int = "integer"; p. ex. `Total.Interactions` = la somme des
`Likes`et `Comments` qu'un post a re√ßu).

Vous pouvez aussi cliquer sur l'objet et explorer le tableau
manuellement pour le comprendre d'avantage (comme nous l'avons fait avec
`mtcars`, etc.).

::: {.callout-caution collapse="false"}
## Attention

-   Vous ne devez pas ouvrir les fichiers CSV avec des autres logiciels
    avant de les importer dans RStudio (par ex. avec Excel), car cela a
    souvent pour cons√©quence de modifier automatiquement le format du
    fichier CSV, ce qui entra√Æne ensuite des erreurs.

-   Vous devriez enregistrer le fichier CSV directement dans votre
    r√©pertoire de travail sans l'ouvrir, puis l'importer dans RStudio √†
    l'aide du menu interactif.

-   Vous devriez √©galement √©viter d'ouvrir le fichier CSV avec des
    applications ou autres (p. ex. application Moodle), ce qui peut
    √©galement entra√Æner des erreurs.

-   Il est pr√©f√©rable de t√©l√©charger les fichiers CSV avec des
    navigateurs standard tels que Chrome ou Safari.
:::

Avant de continuer avec `dplyr`, regardons encore deux √©l√©ments
cruciales pour la manipulation de donn√©es avec R :

-   la transformation du types de variable (p. ex. de variables
    textuelles en facteurs)

-   L'op√©rateur `%>%` (angl. "pipe"; trad. fran√ßaise "tuyau")

## La transformation du type de variable

Lorsque l'on analyse des jeux de donn√©es, on constate parfois que toutes
les variables **ne sont pas enregistr√©es dans un format utile pour
l'analyse**. Parfois, par exemple, les valeurs num√©riques sont
enregistr√©es sous forme de texte. Il est alors utile de les transformer
dans un format num√©rique (par exemple avec la fonction `as.numeric()`.

Mais il y a aussi le cas suivant : les variables sous forme de texte ne
repr√©sentent pas simplement des textes, mais certaines **cat√©gories**.
Dans ce cas, il est judicieux de les transformer en une variable
cat√©gorielle, c'est-√†-dire un facteur, √† l'aide de la fonction
`as.factor()`.

Dans notre exemple de jeu de donn√©es `igposts`, qui contient des
m√©triques sur les posts Instagram, nous pouvons justement constater
cela. Certes, certaines variables textuelles, telles que `URL` (le lien
vers le post) et `Description` (le message textuel associ√© au post
Instagram), sont tout √† fait pertinentes. D'autres, en revanche, sont
des cat√©gories. La plus √©vidente est la variable `Type`, qui indique si
un post Instagram est une photo, une vid√©o ou un album. Factorisons
ci-dessous quelques-unes de ces variables cat√©gorielles √† l'aide de code
:

```{r}
# Transformons les colonnes "Account", "User.Name" et "Type" en facteurs :

igposts$Account <- as.factor(igposts$Account)

igposts$User.Name <- as.factor(igposts$User.Name)

igposts$Type <- as.factor(igposts$Type)

# V√©rifier, si √ßa a march√© :

str(igposts)

```

Nous allons voir par la suite, pourquoi ces factorisations sont utiles.

## L'op√©rateur `%>%`

La fonction principale du pipe `%>%` : construire **une s√©quence de
fonctions ("un tuyau")** qui est plus facile √† comprendre et a lire dans
le code.

```{r}
# Par exemple, regardez la fonction suivante : quel est le probl√®me ?

log(sqrt(mean(c(1:100))))

# Le probl√®me est que cette fonction est imbriqu√©e et, √† cause de cela, difficile √† lire

# Avec le pipe, nous pouvons re√©crire cette fonction comme √ßa et obtenir le m√™me r√©sultat apr√®s ex√©cution du code :

c(1:100) %>% mean() %>% sqrt() %>% log()
```

::: {.callout-tip title="Astuce"}
Vous pouvez cr√©er le pipe `%>%` avec les raccourcis clavier suivants :

-   Sur **Windows** : <kbd>Control</kbd> + <kbd>Shift</kbd> +
    <kbd>M</kbd>

-   Sur **MacOS** : <kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd>

De plus, vous pouvez aussi utiliser `|>` comme op√©rateur pipe alt√©rnatif
(√©quivalent √† `%>%`).
:::

Vous pouvez d√©j√† constater que travailler avec des jeux de donn√©es du
monde r√©el, tels que le jeu de donn√©es Instagram `igposts`, n√©cessite un
travail pr√©paratoire substantiel. Mais rassurez-vous et ne vous
d√©couragez pas, plus vous pratiquez, plus cela devient facile et,
bient√¥t, vous serez en mesure de charger facilement des ensembles de
donn√©es dans RStudio ! Par ailleurs : il est normal de rencontrer des
messages d'erreur. C'est une partie essentielle du processus
d'apprentissage que de les surmonter en bricolant et en jouant avec vos
donn√©es et votre code R jusqu'√† ce que vous puissiez le faire
fonctionner.

Apr√®s avoir charg√© notre fichier CSV dans RStudio, appliqu√© des
transformations et notre connaissance de l'op√©rateur pipe, nous pouvons
maintenant manipuler les donn√©es avec le package `dplyr`.

## Manipuler les donn√©es avec `dplyr`

Le paquet `dplyr` est bas√© sur une logique de *verbes* pour les
diff√©rents types de manipulation de donn√©es, notamment :

-   Les verbes pour manipuler les donn√©es au niveau de **colonnes** :

    -   `select()` : pour extraire une ou plusieurs colonnes d'un data
        frame.

    -   `mutate()` : pour cr√©er une ou plusieurs nouvelles colonnes dans
        un data frame.

-   Les verbes pour manipuler les donn√©es au niveau de **lignes** :

    -   `filter()` : pour filtrer les lignes d'un data frame selon un ou
        plusieurs crit√®res.

    -   `arrange()` : pour trier les lignes d'un data frame selon un ou
        plusieurs crit√®res.

-   Les verbes pour **r√©sumer, compter et regrouper** les donn√©es :

    -   `summarize()` : pour r√©duire une ou plusieurs colonnes d'un data
        frame en une seule ligne, notamment pour r√©sumer des donn√©es.

    -   `count()` : pour compter le nombre d'observations d'une ou
        plusieurs cat√©gories dans un data frame.

    -   `group_by()` : pour regrouper des donn√©es d'un data frame selon
        une ou plusieurs cat√©gories.

Essayons maintenant d'appliquer tout cela avec du code et les donn√©es
`igposts` pour comprendre ce que √ßa veut dire en pratique !

## Manipulation de colonnes : `select()`et `mutate()`

```{r}
#| echo: true
#| output: false
# select() : fonction pour extraire une ou plusieurs colonnes d'un data frame

# Par exemple, nous pouvons extraire les quatres colonnes suivantes d'igposts (voir comment le pipe est utilis√©) :

igposts %>% select(Account, Type, Followers.at.Posting, Total.Interactions)

# Avec les deux points dans la fonction select(), vous pouvez s√©lectionner plusieurs colonnes successives. Notez que cette fois-ci, nous affichons que les six premi√®res lignes avec la fonction head() :

igposts %>% 
  select(Account:Views) %>% 
  head()

# Vous pouvez √©galement cr√©er un nouvel objet, df1, qui est essentiellement un data frame plus petit que igposts avec un sous-ensemble de variables (un tel data frame plus petit peut √™tre plus utile √† analyser et √† afficher) :
  
df1 <- igposts %>% 
          select(Account, 
                 Type, 
                 Followers.at.Posting, 
                 Total.Interactions,
                 URL)


###############################################################################


# mutate() : fonction pour cr√©er une ou plusieurs nouvelles colonnes dans un data frame

# Par exemple, nous pouvons cr√©er une nouvelle colonne qui compte le nombre d'interactions par follower :

df1 %>% mutate(TI_par_Follower = Total.Interactions/Followers.at.Posting)

# Attention, sans op√©rateur <-, nous ne changeons pas l'objet df1 !
# Pour ce faire et sauvegarder notre nouvelle colonne, nous pouvons √©craser df1 avec une nouvelle v√©rsion de df1 :

df1 <- df1 %>% 
        mutate(TI_par_Follower = Total.Interactions/Followers.at.Posting)

str(df1)
```

## Manipulation de lignes avec `filter()` et `arrange()`

```{r}
#| echo: true
#| output: false
# filter() : fonction pour filtrer les lignes selon un ou plusieurs crit√®res

# Pour filtrer pour une valeur sp√©cifique d'une variable, p.ex. les posts de Cristiano Ronaldo : 

df1 %>% filter(Account == "Cristiano Ronaldo")

# Pour plusieurs valeurs sp√©cifique de la m√™me variable, p. ex. les posts de Ronaldo et Messi :

df1 %>% filter(Account %in% c("Cristiano Ronaldo", "Leo Messi"))

# Pour plusieurs valeurs sp√©cifiques de variables diff√©rentes, p. ex. les posts de type Photo de Ronaldo :

df1 %>% 
  filter(Account == "Cristiano Ronaldo", 
         Type == "Photo")

# Filtrer √† partir de valeurs num√©riques, p. ex. les posts avec au moins 10 millions d'int√©ractions :

options(scipen=999) # Cette commande d√©sactive la notation scientifique des nombres

df1 %>% 
  filter(Total.Interactions >= 10000000)

# Filtrer pour les posts de Selena Gomez avec au moins 10 millions d'int√©ractions :

df1 %>% 
  filter(Account == "Selena Gomez", 
         Total.Interactions >= 10000000)

###############################################################################


# arrange() : fonction pour trier les lignes selon un ou plusieurs crit√®res

# Trier des valeurs/facteurs textuelles par ordre alphab√©tique :

df1 %>% arrange(Account) %>% head(10)

# Trier par le nombre d'int√©ractions (ordre croissant)

df1 %>% 
  arrange(Total.Interactions) %>% 
  head(10)

# Trier par le nombre d'int√©ractions par follower (ordre d√©croissant)

df1 %>% 
  arrange(desc(TI_par_Follower)) %>% 
  head(10)
```

## R√©sumer, compter et regrouper avec `summarize()`, `count()` et `group_by()`

```{r}
#| echo: true
#| output: false
# summarize() : fonction qui r√©duit une ou plusieurs colonnes en une seule ligne, 
# notamment pour r√©sumer des donn√©es

# Nous pouvons, par exemple, r√©sumer la somme totale de Total.Interactions dans notre ensemble de donn√©es. Ce nombre est assez impressionnant et constitue une caract√©ristique importante de notre ensemble de donn√©es.

df1 %>% summarize(sum_TI = sum(Total.Interactions)) 

# Nous pouvons aussi calculer les moyennes des int√©ractions et de followers de tout les comptes qui ont publi√© les posts :

df1 %>% 
  summarize(mean_TI = mean(Total.Interactions), 
                  mean_Followers = mean(Followers.at.Posting)) 


###############################################################################


# count() : fonction qui compte le nombre d'observations d'une ou plusieurs cat√©gories

# Compter l'occurence des types de posts Instagram (Photo et Album, dans ce cas) dans notre jeu de donn√©es :

df1 %>% 
  count(Type)

# Compter l'occurence des diff√©rents comptes dans notre jeu de donn√©es :

df1 %>% 
  count(Account)

# Compter l'occurence des diff√©rents comptes dans notre jeu de donn√©es en les triant par cette occurence de mani√®re d√©croissante (avec le param√®tre arrange(-n)) :

df1 %>% 
  count(Account) %>% 
  arrange(-n) %>% 
  head(10)


###############################################################################


# group_by() : fonction qui regroupe des donn√©es selon une ou plusieurs cat√©gories

# Regroupement par type de post et comparaison du nombre moyen d'interactions par type de post :

df1 %>% group_by(Type) %>% summarize(mean_TI = mean(Total.Interactions)) 

# En utilisant le param√®tre n=n() dans la fonction summarize(), nous pouvons √©galement compter le nombre d'observations dans chaque cat√©gorie :

df1 %>% 
  group_by(Type) %>% 
  summarize(n = n(), 
            mean_TI = mean(Total.Interactions)) 

# Utilisons plusieurs verbes dplyr pour trouver les 10 comptes qui apparaissent le plus fr√©quemment dans nos ensembles de donn√©es de posts Instagram. Nous r√©sumons √©galement leur nombre moyen de followers et d'interactions.

df1 %>% 
  group_by(Account) %>% 
  summarize(n = n(), 
            mean_Followers = mean(Followers.at.Posting),
            mean_TI = mean(Total.Interactions)) %>% 
  arrange(desc(n)) %>% 
  head(10)

# Utilisons plusieurs verbes dplyr pour comparer les Likes et Comments des posts de Ronaldo et Messi :

igposts %>%
  group_by(Account) %>%
  filter(Account %in% c("Cristiano Ronaldo", "Leo Messi")) %>% 
  summarize(n = n(), mean_Followers = mean(Followers.at.Posting),
            mean_Likes = mean(Likes),
            mean_Comments = mean(Comments)) 
```

### Devoir pour Session 8 et infos questionnaire

-   Assurez-vous que vous pouvez charger correctement le fichier de
    donn√©es igposts.csv dans votre session R active.
-   Nous t√©l√©chargerons d√©sormais r√©guli√®rement des fichiers CSV avec
    des jeux de donn√©es, c'est pourquoi ce processus doit fonctionner
    sur votre ordinateur portable. (Cela s'applique √©galement aux
    Problem Sets 3 et 4).
-   **Questionnaire** : Merci √† toutes et tous les √©tudiant-e-s qui ont
    rempli le questionnaire avant la date limite (31 mars 2025). Vous
    recevrez 2 points bonus dans le Problem Set 4. Ceux-ci seront
    ajout√©s s√©par√©ment √† la fin du cours, lorsque la note finale sera
    d√©termin√©e.
-   Nous commencerons bient√¥t √† √©valuer les donn√©es du questionnaire
    dans l'exercice.
-   Si vous avez rencontr√© des difficult√©s lors des deux premiers
    Problem Sets, assurez-vous que vous pouvez ex√©cuter correctement sur
    votre ordinateur portable tout le code R trait√© jusqu'√† pr√©sent dans
    le cours et que vous comprenez bien toutes les √©tapes. Nous vous
    rappellons que tout le contenu de la page GitHub et de la page
    Moodle du cours est pertinent pour les Problem Sets (pas seulement
    ce qui a √©t√© discut√© en classe).

{{< pagebreak >}}

# Session 8 \| Manipuler les donn√©es II

**Sujet : Manipuler les donn√©es (partie 2)**

L'objectif de la session 8 est de vous entra√Æner √† r√©soudre de mani√®re
autonome des probl√®mes de manipulation de donn√©es √† l'aide du code R et
de vous pr√©parer ainsi au Problem Set 3.

Les exercices suivants se composent d'une question et d'une solution
mod√®le sous forme de code R. Notez qu'en programmation R, il y a souvent
plusieurs solutions pour arriver √† la r√©ponse correcte.

::: {.callout-tip title="Conseil"}
Pour un meilleur effet d'apprentissage : essayez d'abord de r√©soudre la
question avec votre propre script R sans consulter imm√©diatement la
solution mod√®le. Comparez ensuite votre propre code avec celui de la
solution mod√®le.
:::

## Exercices avec solutions

### 0 : Pr√©parez-vous pour l'exercice

-   Commencez en ouvrant un nouveau script R.

-   Nommez le `script_session_8` et sauvegardez le sur votre ordinateur.
    (D√©finissez votre r√©p√©rtoire de travail avec `setwd()` et
    sauvegardez le code de la console dans le script).

-   Chargez le paquet tidyverse avec `library(tidyverse)`.

### 1 : mtcars I

-   Affichez la structure de `mtcars`avec `str(mtcars)`.
-   S√©lectionnez ensuite les colonnes `mpg` et `cyl` de `mtcars` avec
    `dplyr`.

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: false
str(mtcars)

mtcars %>% 
  select(mpg,cyl)
```
:::

### 2 : mtcars II

-   Filtrez mtcars pour `mpg >= 25` !

-   Combien de mod√®les de voitures dans `mtcars` r√©pondent √† ce crit√®re
    ?

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
mtcars %>% 
  filter(mpg >= 25)

# Six mod√®les de voitures ont une valeur mpg d'au moins 25 dans mtcars.
```
:::

### 3 : mtcars III

-   Triez `mtcars` par `mpg` dans l'ordre d√©croissant !

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
mtcars %>% 
  arrange(desc(mpg))
```
:::

### 4 : mtcars IV

-   Cr√©ez une nouvelle variable (colonne) dans mtcars, nomm√© `mpg_wt`,
    d√©finie comme le nombre de `mpg` par unit√© de poids (`wt`) !

-   Sauvegardez la v√©rsion modifi√©e de `mtcars` avec l'op√©rateur
    d'affectation sous l'objet `mtcars_v2`.

-   Affichez la nouvelle colonne `mpg_wt` de `mtcars_v2` en la triant
    par ordre d√©croissant !

-   Quel mod√®le de voiture de `mtcars` est le plus √©conome en carburant
    par rapport √† son poids ?

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
mtcars_v2 <- mtcars %>% 
  mutate(mpg_wt = mpg/wt)

mtcars_v2 %>% 
  select(mpg_wt) %>% 
  arrange(desc(mpg_wt))

# Le Lotus Europa est le plus √©conome en carburant par rapport √† son poids.
```
:::

### 5 : diamonds I

-   Affichez encore une fois `str(diamonds)` !
-   Utilisez des verbes `dplyr`pour compter le nombre de diamants dans
    `diamonds`qui p√®sent plus de 3 carats !

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
diamonds %>% 
  count(carat > 3 )

# Solution alternative : 

diamonds %>% 
  filter(carat > 3) %>% 
  count()

# Le crit√®re carat > 3 s'applique √† 32 diamants dans diamonds.
```
:::

### 6 : diamonds II

-   Calculez le prix moyen en USD des diamants dans `diamonds` !

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
diamonds %>% 
  summarize(prix_moyen = mean(price))

# Solution alternative (sans dplyr) : 

mean(diamonds$price)
```
:::

### 7 : diamonds III

-   Calculez le prix moyen en USD des diamants des diff√©rentes
    cat√©gories de puret√© (`clarity`) dans `diamonds` !
-   Triez le r√©sultat par ordre d√©croissant des prix moyens
-   Quelle cat√©gorie de puret√© est la plus ch√®re en moyenne dans
    `diamonds` ?

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
diamonds %>% 
  group_by(clarity) %>% 
  summarize(prix_moyen = mean(price)) %>% 
  arrange(desc(prix_moyen))

# Avec un prix par diamant de 5063 USD en moyenne, la cat√©gorie de puret√© SI2 est la plus ch√®re dans diamonds.
```
:::

### 8 : mtcars V

-   Regroupez mtcars par `gear`, puis, √† l'aide de `summarize()`,
    calculez `n`, la m√©diane et la variance de mpg.

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
mtcars %>% 
  group_by(gear) %>% 
  summarize(n = n(),
            median_mpg = median(mpg), 
            var_mpg = var(mpg))
```
:::

### 9 : iris I

-   S√©lectionner `Petal.Length`, `Petal.Width`, et `Species` dans
    `iris`.
-   Ensuite, utilisez `mutate()` pour cr√©er une nouvelle colonne,
    appel√©e `Petal.Surface`, qui est le produit de `Petal.Length` et
    `Petal.Width`.
-   Regroupez ensuite les donn√©es par esp√®ce et utilisez `summarize()`
    pour calculer une nouvelle variable : `mean_Petal.Surface`.

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
str(iris)

iris %>% 
  select(Petal.Length, Petal.Width, Species) %>%
  mutate(Petal.Surface = Petal.Length*Petal.Width) %>% 
  group_by(Species) %>% 
  summarise(mean_Petal.Surface = mean(Petal.Surface))

# Les iris de l'esp√®ce virginica ont les plus grandes surfaces de p√©tales (en moyenne).
```
:::

### 10 : diamonds IV

-   Utilisez les verbes de `dplyr` pour calculer la moyenne des prix en
    USD par carat dans `diamonds`.
-   Montrez les r√©sultats, tri√©s par ordre d√©croissant de dollars par
    `carat`, pour les diff√©rentes cat√©gories de taille (`cut`).
-   Montrez aussi `n`, le nombre de diamants par cat√©gorie de taille.

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
diamonds %>% 
  select(carat, cut, price) %>% 
  mutate(USD_per_carat = price/carat) %>% 
  group_by(cut) %>% 
  summarize(n = n(), mean_USD_per_carat = mean(USD_per_carat)) %>% 
  arrange(desc(mean_USD_per_carat)) 

# En moyenne, les diamants de la meilleure qualit√© de taille (Ideal) ne sont pas les plus chers dans diamonds.
```
:::

### 11 : igposts I

-   Chargez le jeu de donn√©es `igposts`que nous avons vu pendant session
    7.  
-   Si n√©cessaire, t√©l√©chargez le encore une fois depuis Moodle et
    sauvegardez le dans le dossier de votre ordinateur que vous avez
    d√©finit comme r√©p√©rtoire de travail.
-   Si n√©cessaire, transformez encore une fois les colonnes
    `igposts$Account`, `igposts$User.Name`et `igposts$Type` en variables
    cat√©gorielles avec `as.factor()`.

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
# Vous pouvez copier-coller le code que nous avons utilis√© la derni√®re fois (modifiez-le pour votre ordi) :
igposts <- read.csv("/Users/domus_julian/Documents/GitHub/intro-a-R/code/igposts.csv", encoding="UTF-8", na.strings="#N/A")

# Appliquez encore une fois les transformations de variables, si n√©cessaire :

igposts$Account <- as.factor(igposts$Account)

igposts$User.Name <- as.factor(igposts$User.Name)

igposts$Type <- as.factor(igposts$Type)

# V√©rifier, si √ßa a march√© :

str(igposts)
```
:::

### 12 : igposts II

-   Utilisez `dplyr` pour trouver le nombre `n`de posts Instagram
    regroup√©s par compte des influenceurs dans `igposts`.
-   Affichez les 10 premiers par ordre d√©croissant de `n`.

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
igposts %>% 
  group_by(Account) %>% 
  summarize(n = n()) %>% 
  arrange(desc(n)) %>% 
  head(10)
```
:::

### 13 : igposts III

-   Utilisez `dplyr` pour calculer le nombre moyen de `Likes`,
    `Comments`et `Views`par compte (`Account`) des influenceurs dans
    `igposts`.
-   Triez-les par ordre d√©croissant de la moyenne des `Likes`.
-   Affichez les top 10.

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
igposts %>% 
  group_by(Account) %>% 
  summarize(mean_Likes = mean(Likes), mean_Comments = mean(Comments), mean_Views = mean(Views)) %>% 
  arrange(desc(mean_Likes)) %>% 
  head(10)
```
:::

### 14 : igposts IV

-   Utilisez `dplyr` pour afficher les variables `Account`, `Likes` et
    `URL` des 5 posts dans `igposts` qui ont re√ßu le plus de `Likes`.
-   Allez voir l'URL du post avec le plus de `Likes` : De quoi s'agit-il
    ?

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
#| warning: false
igposts %>% 
  select(Account, Likes, URL) %>% 
  arrange(desc(Likes)) %>% 
  head(5)

# Le post Instagram le plus lik√© dans igposts est un post de type album de Leo Messi dans lequel il met en sc√®ne un prix qu'il a re√ßu de la FIFA.
```
:::

[URL Instagram du post de Leo
Messi](https://www.instagram.com/p/CpLxnFlNJZn/)

### 15 : igposts V

-   Faites la m√™me chose que dans la question 14, mais maintenant pour
    les `Comments` au lieu des `Likes` !
-   Allez voir l'URL du post avec le plus de `Comments` : De quoi
    s'agit-il ?

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
igposts %>% 
  select(Account, Comments, URL) %>% 
  arrange(desc(Comments)) %>% 
  head(5)

#Le post Instagram ayant re√ßu le plus de commentaires dans igposts est de type photo et a √©t√© publi√© par Selena Gomez. Il la repr√©sente en train de boire un cocktail et de flirter avec la cam√©ra.
```
:::

[URL du post Instagram de Selena
Gomez](https://www.instagram.com/p/Co_P7YgrrFO/)

### 16 : igposts VI

-   Faites la m√™me chose que dans les questions 14 et 15, mais
    maintenant pour les `Views` (√† noter : Dans Instagram, la m√©trique
    `Views`d√©signe les **video views** uniquement ) !
-   Allez voir l'URL du post avec le plus de `Views` : De quoi s'agit-il
    ?

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
igposts %>% 
  select(Account, Views, URL) %>% 
  arrange(desc(Views)) %>% 
  head(5)

#Le post Instagram qui a re√ßu le plus de Views (vid√©os vues) dans igposts est un post d'album de Kendall Jenner dans lequel elle partage de courtes s√©quences de selfie d'elle-m√™me, partageant un moment intime avec ses followers (le son ne semble plus fonctionner).
```
:::

[URL du post Instagram de Kendall
Jenner](https://www.instagram.com/p/CoYqX0hr1jr/)

### 17 : igposts VII

-   Utilisez dplyr pour cr√©er une nouvelle colonne :
    `Likes_par_Follower` (d√©finie comme `Likes` divis√© par
    `Followers.at.Posting`).
-   Trouvez maintenant le post avec le plus grand nombre de
    `Likes_par_Follower` et naviguez jusqu'√† son URL : que montre-t-il ?

::: {.callout-caution collapse="true"}
### Solution

```{r}
igposts %>% 
  mutate(Likes_par_Follower = Likes/Followers.at.Posting) %>% select(Account, Likes_par_Follower, URL) %>% 
  arrange(desc(Likes_par_Follower)) %>% 
  head(5)

#Le post Instagram qui a re√ßu le plus de Likes par follower dans igposts est un post de type album de Anastasia Karanikolaou, une amie de Kylie Jenner. Les photos montres les deux amies sur une place de basketball en faisant des grimaces.
```
:::

[URL du post Instagram de Anastasia
Karanikolaou](https://www.instagram.com/p/CoptMRoJtUD/)

### 18 : igposts VIII

-   Faites la m√™me chose qu'√† la question 17, mais cette fois cr√©ez la
    variable `Comments_par_Follower`.

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
igposts %>% 
  mutate(Comments_par_Follower = Comments/Followers.at.Posting) %>% select(Account, Comments_par_Follower, URL) %>% 
  arrange(desc(Comments_par_Follower)) %>% 
  head(5)

#Le post Instagram qui a re√ßu le plus de commentaires par follower dans igposts est un post d'album de l'actrice indienne Kiara Advani avec des photos de son mariage.
```
:::

[URL du post Instagram de
KIARA](https://www.instagram.com/p/CoXmBSLvj7A/)

### 19 : igposts IX

-   Faites la m√™me chose que dans les questions 17 et 18, mais cette
    fois pour `Views_par_Follower` (ne calculez cette variable que pour
    les posts qui ont re√ßu plus de 0 vues).

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
igposts %>% 
  filter(Views > 0) %>% 
  mutate(Views_par_Follower = Views/Followers.at.Posting) %>% select(Account, Views_par_Follower, URL) %>% 
  arrange(desc(Views_par_Follower)) %>% 
  head(5)

#Le post Instagram qui a re√ßu le plus de views par follower est un album publi√© par la chanteuse colombienne Karol G. Le post montre des photos et une vid√©o d'elle avec Rihanna.
```
:::

[URL du post Instagram de Karol
G](https://www.instagram.com/p/ComtUDjrPAD/)

{{< pagebreak >}}

# Session 9 (Problem Set 3)

Les r√©sultats du **Problem Set 3** (bonnes r√©ponses, √©chelle des notes)
sont acc√©ssibles sur la page Moodle de l'exercice.

Voici l'histogramme des points obtenus par n = 64 √©tudiant-e-s qui ont
particip√© au Problem Set 3 le 16 et 17 avril 2025 dans trois groupes (A,
B, C).

-   Le nombre maximal de points √©tait de 20, il fallait 10 pour passer
    le test.

-   La moyenne des points obtenus √©tait de 13.1 (note = 4.5).

-   58 √©tudiant-e-s (90.6%) ont r√©ussi Problem Set 3.

```{r}
#| echo: false
#| output: true
#| warning: false
# script pour faire un histogramme des points obtenus dans le Problem Set 3
# cours : Exercices M√©thodes II
# date : 16/17 avril 2025
# auteur : Julian Maitra

library(ggplot2)

# Adaptez le code suivant pour votre r√©pertoire de travail :

setwd("/Users/domus_julian/Documents/GitHub/intro-a-R/code")

# Enregistrez le fichier CSV points_ps_3 dans votre r√©pertoire de travail, 
# puis importez les donn√©es dans R (modifiez le code suivant selon votre ordinateur) :

points_ps_3 <- read.csv("~/Documents/GitHub/intro-a-R/code/points_ps_3.csv", encoding="UTF-8")

#points_ps_3 # il y a 64 observations

hist_ps_3 <-ggplot(points_ps_3, 
                   aes(x=points_ps_3)) + 
  geom_histogram(binwidth = 1, color="black", fill="white") +
  labs(title = "Histogramme des points obtenus dans le PS 3", 
       subtitle = "n = 64 r√©sultats de test", 
       caption = "Source des donn√©es : Moodle") +       
  xlab("Points obtenus") +                             
  ylab("Fr√©quence") + 
  theme_minimal() +
  coord_cartesian(xlim = c(0,20), ylim = c(0,14)) +
  scale_x_continuous(breaks = seq(0,20, by=1)) +
  scale_y_continuous(breaks = seq(0,14, by=2)) +
  geom_vline(aes(xintercept=9.5),
             color="red",  linewidth=1, linetype="dashed")
hist_ps_3
```

{{< pagebreak >}}

# Session 10 \| Statistiques descriptives

**Sujet : La statistique descriptive**

::: {.callout-note icon="true"}
## √Ä noter

La **statistique descriptive** est g√©n√©ralement la premi√®re √©tape d'une
analyse statistique. Elle aide √† comprendre le jeu de donn√©es et ses
caract√©ristiques √† un niveau descriptif.

Il ne s'agit donc **pas** d'analyser des **relations de cause √† effet**
(c'est en effet le r√¥le de la *statistique inf√©rentielle*).

Les mesures suivantes font souvent partie des statistiques descriptives
(souvent appel√©s *summary statistics* en anglais) et sont utilis√©es pour
une premi√®re analyse des variables de type num√©rique d'un jeu de
donn√©es.

-   La taille de l'√©chantillon (nombre d'observations *n*)

-   Les mesures de tendance centrale (moyenne, m√©diane, mode)

-   Les mesures de dispersion (√©tendue, variance, √©cart-type, kurtosis,
    etc.)

-   Les mesure de position (percentiles, quartiles)

Ces mesure permettent d'obtenir une premi√®re id√©e de la structure d'un
jeu de donn√©es. Elles permettent √©galement d'identifier des valeurs
extr√™mes (angl. *outliers*) qui peuvent jouer un r√¥le important dans un
jeu de donn√©es.

Des mesures concernant les **variables cat√©gorielles** peuvent √©galement
faire partie d'une analyse d√©scriptive, notamment :

-   La fr√©quence de chaque cat√©gories (p. ex. combien de participant-e-s
    √† un questionnaire sont des femmes ?)
-   La r√©partition des diff√©rentes cat√©gories (p. ex. quel est le
    pourcentage de femmes dans l'√©chantillon ?)
:::

Dans la a mise en ≈ìuvre d'une analyse statistique, par exemple dans un
travail scientifique, les statistiques descriptives sont souvent
pr√©sent√©es sous deux formats :

-   des **tableaux** pour les mesures telles que la taille de
    l'√©chantillon, les moyennes, etc. Souvent aussi pour diff√©rentes
    cat√©gories, p. ex. hommes et femmes.

-   des **graphiques** pour la visualisation de distributions, par
    exemple des histogrammes, et des r√©partitions de variables
    cat√©gorielles, par exemple par le biais de diagrammes √† barres.

Lorsque l'on veut repr√©senter des statistiques descriptives dans R, il
est souvent utile de combiner les deux paquets R `dplyr` et `ggplot2`.
C'est une bonne nouvelle, car nous avons d√©j√† examin√© les principaux
codes R n√©cessaires pour utiliser ces deux paquets dans ce cours.

Pour nous entra√Æner √† nouveau, cette fois avec nos propres donn√©es, nous
allons proc√©der ci-dessous √† une analyse descriptive des r√©ponses au
questionnaire (version de 2024) !

Vous verrez donc par la suite comment ce que nous avons appris jusqu'√†
pr√©sent dans le cours peut √™tre combin√© de mani√®re utile.

## Analyse des r√©ponses au questionnaire, 1√®re partie (stats d√©scriptives)

Veuillez ouvrir un nouveau script R et charger les paquets `tidyverse`
et `ggthemes`. Ensuite, vous pouvez d√©finir votre r√©p√©rtoire de
travaille.

Vous pouvez ensuite t√©l√©charger le fichier `reponses_socio.csv` depuis
la page Moodle du cours (mat√©riel de la 10√®me session) et le sauvegarder
dans votre r√©p√©rtoire de travail.

![Param√®tres pour l'importation du fichier
`reponses_socio.csv`.](images/Screenshot%202024-05-01%20at%2009.09.22.png)

```{r}
#| echo: true
#| output: true
#| warning: false

# Script session 10

library(tidyverse)
library(ggthemes)

# vous devez modifier les fonctions setwd() et read.csv() pour correspondre √† votre ordinateur :
setwd("/Users/domus_julian/Documents/GitHub/intro-a-R/code")

reponses_socio <- read.csv("/Users/domus_julian/Documents/GitHub/intro-a-R/code/reponses_socio.csv", encoding="UTF-8", stringsAsFactors=TRUE)

# Contr√¥le, si √ßa a march√©
str(reponses_socio)

# Une formidable fonction pour analyser les stats d√©scriptives : summary()
summary(reponses_socio)

# Abordons maintenant quelques questions plus sp√©cifiques auxquelles nous pouvons r√©pondre √† l'aide de statistiques descriptives


# 1. Trajet pour arriver √† l'universit√©
#*****************************************

# histogramme tr√®s basique
ggplot(data = reponses_socio,
       mapping = aes(x=trajet)) +
  geom_histogram(binwidth = 10)

# plus sophistiqu√©
ggplot(data = reponses_socio,
       mapping = aes(x=trajet)) +
  geom_histogram(binwidth = 10, 
                 fill = "steelblue",
                     color = "black") +
  labs(title = "Trajets en minutes des √©tudiant-e-s pour arriver √† l'UniFR",
       subtitle = "Questionnaire avec n = 74 participant-e-s",
       x = "Trajet en minutes",
       y = "Fr√©quence") +
  theme_minimal()


# 2. histogramme des ann√©es de naissance
#*****************************************

ggplot(data = reponses_socio,
       mapping = aes(x=naissance)) +
  geom_histogram(binwidth = 1, fill = "lightgreen", color = "black") +
  labs(title = "Ann√©es de naissance",
       subtitle = "n = 74 r√©pondants √† un questionnaire",
       x = "Ann√©e de naissance",
       y = "Fr√©quence")+
  theme_minimal()


# 3. diagramme √† barres des genres
#*****************************************

ggplot(data = reponses_socio,
       mapping = aes(x=genre, 
             fill=genre)) +
  geom_bar()

# graphique plus sophistiqu√©e

# changer d'abord l'ordre des cat√©gories (commen√ßant avec la plus fr√©quente)

ordre = c("Femme", "Homme", "Autre")

# Puis combiner dplyr avec ggplot2 !
reponses_socio %>% 
  select(genre) %>% 
  mutate(genre = factor(genre, levels = ordre)) %>% 
  arrange(genre) %>% 
ggplot(aes(x=genre, fill=genre)) +
  geom_bar(show.legend = FALSE) +
  labs(title = "R√©partition des genres",
       subtitle = "n = 74 r√©pondants √† un questionnaire",
       x = "Genre",
       y = "Fr√©quence",
       legend = "") +
  theme_minimal()


# 4. Moyennes des notes
#*****************************************

mean(reponses_socio$note_ecole, na.rm = TRUE)

mean(reponses_socio$note_uni, na.rm = TRUE)

min(reponses_socio$note_uni, na.rm = TRUE)

min(reponses_socio$note_ecole, na.rm = TRUE)

reponses_socio %>% 
  select(note_ecole,note_uni, genre) %>% 
  group_by(genre) %>% 
  filter(note_ecole > 3.99,
         note_uni > 0.99) %>% 
  summarize(n = n(), note_ecole_moyenne = mean(note_ecole),
            note_uni_moyenne = mean(note_uni))

# Visualisation de la relation entre note_ecole et note_uni
reponses_socio %>% 
  select(note_ecole,note_uni) %>% 
  filter(note_ecole > 3.99,
         note_uni > 0.99) %>% 
ggplot(aes(x=note_uni, y=note_ecole)) +
         geom_point() +
  geom_smooth(method = "lm")


# 5. Permis de conduire
#*****************************************

table(reponses_socio$permis)

table(reponses_socio$suisse)

reponses_socio %>% 
  select(permis, suisse) %>% 
  filter(permis !="N/A") %>% 
  group_by(suisse,permis) %>% 
  summarize(n = n())
```

## La fonction `write.csv()`

Avec R, vous ne pouvez pas seulement lire des donn√©es au format CSV
(entr√©e de donn√©es ; avec des fonctions telles que `read.csv()`), mais
vous pouvez √©galement cr√©er des fichiers CSV √† partir de votre session
en cours (sortie de donn√©es), notamment avec la fonction `write.csv()` !

La syntaxe de la fonction n√©cessite comme arguments le nom du data frame
que vous voulez sauvegarder comme CSV ainsi que le chemin du fichier sur
votre ordinateur qui inclut le nom que vous voulez donner au ficher CSV
: `write.csv(nom_df, "chemin_du_fichier/nom_du_ficher.csv")`

```{r}
# Voici un exemple avec du code (recr√©ons le tableau avec les animaux de Ice Age !)

name <- c("Manny", "Sid", "Diego", "Ellie", 
          "Peaches", "Scrat", "Rudy", "Buck")

species <- c("mammoth", "sloth", "sabertooth", "mammoth", 
             "mammoth", "squirrel", "dinosaur", "weasel")

female <- c(FALSE, FALSE, FALSE, TRUE, 
            TRUE, FALSE, FALSE, FALSE)

age <- c(30, 20, 35, 25, 
         7, 4, 100, 28)

weight <- c(5000, 80, 400, 4000, 
            1000, 1, 10000, 3)

ice_age_df <- data.frame(name, species, female, age, weight)

print(ice_age_df)

# Maintenant, notre but est de cr√©er un ficher CSV qui contient les donn√©es du data frame ice_age_df
# Il faut adapter le chemin du fichier suivant pour qu'il marche sur votre ordinateur :

write.csv(ice_age_df, file = "/Users/domus_julian/Documents/GitHub/intro-a-R/code/ice_age_df.csv")

```

Si tout a bien march√©, vous devrez maintenant avoir un ficher CSV, nomm√©
`ice_age_df.csv`dans votre r√©p√©rtoire de travail !

{{< pagebreak >}}

# Session 11 \| Statistiques inf√©rentielles I

**Sujet : La statistique inf√©rentielle, Partie 1 (tests t)**

Dans cette et la prochaine session, nous allons nous concentrer sur
trois m√©thodes de statistiques inf√©rentielles couramment utilis√©es :

-   Les **tests t** (angl. Student's t-test)

-   l'**analyse de variance** (angl. **ANOVA** = ANalysis Of VAriance)

-   La **r√©gression lin√©aire** (angl. linear regression).

Mais d'abord, il faut r√©pondre √† la question suivante :

## C'est quoi la statistique inf√©rentielle ?

::: {.callout-note icon="true"}
## √Ä noter

Les statistiques inf√©rentielles sont une branche des statistiques qui
permet de tirer des conclusions g√©n√©rales sur une population enti√®re en
se basant sur l'analyse statistique d'un √©chantillon repr√©sentatif de
cette population.
:::

En sciences sociales, les statistiques inf√©rentielles sont souvent
utilis√©es pour d√©montrer des corr√©lations et des relations de cause √†
effet entre des variables. Nous voulons savoir, par exemple, si le genre
(variable x) a une influence sur les notes de maturit√© (variable y).

En g√©n√©ral, pour analyser de telles relations, nous formulons souvent
des hypoth√®ses bas√©es sur des th√©ories ou des suppositions tir√© de la
litt√©rature d'un domaine de recherche, que nous pouvons ensuite tester
sur notre √©chantillon. Les r√©sultats obtenus nous permettent de
confirmer ou d'infirmer nos hypoth√®ses et de g√©n√©raliser les conclusions
√† la population enti√®re. Ceci nous permet de contribuer √† la cr√©ation de
nouvelles connaissance dans notre domaine de recherche

## le test t

::: {.callout-note icon="true"}
## √Ä noter

Le test t est est un outil statistique qui permet d'√©valuer les moyennes
d'un ou deux √©chantillons √† l'aide d'un test d'hypoth√®se. Il est aussi
appel√© test t de Student, car le statisticien qui l'a invent√© au d√©but
du 20√®me si√®cle, William Sealy Gosset, a publi√© sous le pseudonyme de
"Student" ([Wikip√©dia,
2024](https://en.wikipedia.org/wiki/Student%27s_t-test)).
:::

::: {.callout-caution collapse="false"}
## Attention

Pour effectuer un test t, il y a plusieurs hypoth√®ses qui doivent √™tre
satisfaites :

1.  **Les donn√©es sont continues**
2.  **L'√©chantillonnage est al√©atoire**
    -   Les donn√©es de chaque √©chantillon ont √©t√© pr√©lev√©es au hasard
        dans une population.
3.  **Ind√©pendance**
    -   Les observations doivent √™tre ind√©pendantes les unes des autres.
        Cela signifie que la valeur d'une observation ne doit pas
        d√©pendre de la valeur d'une autre observation.
    -   Pour les tests t √† deux √©chantillons, les √©chantillons doivent
        √™tre ind√©pendants. Si les √©chantillons ne sont pas ind√©pendants,
        un test t pour √©chantillons appari√©s peut √™tre appropri√©.
4.  **Normalit√©**
    -   La variable continue √©tudi√©e doit (plus ou moins) suivre une loi
        normale dans chaque groupe ou √©chantillon.
    -   Cette hypoth√®se peut √™tre v√©rifi√©e √† l'aide de graphiques (comme
        un histogramme) ou de tests statistiques (comme [le test de
        Shapiro-Wilk](https://www.statology.org/shapiro-wilk-test-r/) :
        `shapiro.test()`).
5.  **Homog√©n√©it√© des variances (homosc√©dasticit√©)**
    -   Les variances des donn√©es dans chaque groupe est similaire.
    -   Cette hypoth√®se peut √™tre v√©rifi√©e √† l'aide [du test de Levene
        ou du test de
        Bartlett](https://www.datanovia.com/en/lessons/homogeneity-of-variance-test-in-r/).

En pratique, les tests t sont relativement robustes aux d√©viations de
ces hypoth√®ses, surtout si le nombre d'observations (n) de chaque
√©chantillon est important.

N√©anmoins, si une ou plusieurs de ces hypoth√®ses n'est pas satisfaite,
alors des alternatives au test t peuvent √™tre utilis√©es, comme [le test
de Wilcoxon-Mann-Whitney](#0) (`wilcox.test()`) ou [le test de
Kruskal-Wallis](#0) (`kruskal.test()`).
:::

Dans R, le test t est √©ffectu√© avec la fonction `test.t()`.

Il existe **trois types** de tests t :

1.  **Le test t √† un √©chantillon** (angl. *one sample t-test*) : pour
    √©valuer si la moyenne d'un seul √©chantillon diff√®re de mani√®re
    significative d'une valeur connue.

    -   Par exemple, si la moyenne des notes d'un groupe de 30 lyc√©ens,
        qui est de 4.9, est significativement diff√©rente de 5.0 ou non.

2.  **Le test t √† deux √©chantillons ind√©pendants** (angl. *two sample
    t-test* ; aussi appel√© *Welch two sample t-test*) : pour √©valuer si
    les moyennes de deux √©chantillons ind√©pendants diff√®rent de mani√®re
    significative.

    -   Par exemple, si la moyenne des notes de 30 lyc√©ennes, qui est de
        5.0, est significativement diff√©rente ou non de la moyenne des
        notes de 30 lyc√©ens, qui est de 4.8.

3.  **Le test t pour √©chantillons appari√©s** (angl. *pairwise t-test*) :
    pour comparer les moyennes de deux groupes qui sont li√©s ou appari√©s
    d'une certaine mani√®re. Dans ce type de test, chaque participant est
    mesur√© deux fois, une fois dans chaque groupe, ce qui permet de
    r√©duire les effets des variations individuelles.

    -   Par exemple, nous pourrions enregistrer la moyenne des notes
        d'une classe de 30 √©l√®ves avant et apr√®s un cours de soutien
        scolaire en ligne. Il y a donc deux mesures pour chaque √©l√®ve.
        Le cours de soutien scolaire est dans ce cas un traitement.

    -   (√† noter : nous n'allons pas traiter ce type de test t plus en
        d√©tail dans l'exercice).

Voyons maintenant des exemples avec du code !

### Exemple 1 : test t √† un √©chantillon

**Probl√®me** : Tester si la moyenne de QI d'un √©chantillon
d'√©tudiant-e-s, qui est de 105, est diff√©rente de mani√®re significative
de la moyenne de la population, qui est de 100.

-   Notre **hypoth√®se H1** (angl. *alternative hypothesis*) stipule
    qu'il y a une diff√©rence significative entre le QI des √©tudiant-e-s
    et celui de la population g√©n√©rale. En effet, nous assumons que le
    QI des √©tudiant-e-s est plus √©lev√© que celui de la population.

-   L'**hypoth√®se nulle H0** (angl. *null hypothesis*) serait donc le
    contraire, c'est √† dire que la diff√©rence n'est pas significative
    entre les deux groupes.

√Ä noter : dans le code qui suit, nous allons encore une fois utiliser la
fonction `rnorm()` que nous avons vu en classe pour cr√©er des valeurs
"al√©atoires" qui suivent une loi normale. Nous pouvons utiliser ces
valeurs pour simuler notre probl√®me.

```{r}
# G√©n√©rer des donn√©es d'√©chantillon avec n = 25 observations hypoth√©tiques de QI d'√©tudiant-e-s.
# Nous simulons, avec rnorm() 25 observations qui suivent une loi normale avec une moyenne de 105 et un √©cart-type de 15
set.seed(123)
scores_qi <- rnorm(25, mean = 105, sd = 15)

# Test t √† un √©chantillon o√π
# il faut 2 arguments dans la fonction t.test() : (1) les donn√©es √† tester (scores_qi) et (2) la valeur √† laquelle on veut comparer les donn√©es (mu = 100)
resultat_test_t <- t.test(scores_qi, mu = 100)
print(resultat_test_t)
```

Il s'agit maintenant d'interpr√©ter le r√©sultat du test t dans R.

-   **La statistique t** quantifie la diff√©rence entre les moyennes des
    groupes par rapport √† la variabilit√© de l'√©chantillon. Le signe de
    la statistique t indique si la moyenne de l'√©chantillon est
    sup√©rieure (t positif) ou inf√©rieure (t n√©gatif) √† la moyenne de la
    comparaison. L'ampleur refl√®te combien d'erreurs standard la
    diff√©rence est par rapport √† z√©ro. En g√©n√©ral, des valeurs absolues
    plus √©lev√©es sugg√®rent des preuves plus solides contre l'hypoth√®se
    nulle, ce qui se traduit par des valeurs p plus faibles.

-   **df** signifie "degrees of freedom". Dans un test t, les degr√©s de
    libert√© font r√©f√©rence au nombre de valeurs dans le calcul final
    d'une statistique qui sont libres de varier. Il s'agit d'une mesure
    de la quantit√© d'informations disponibles pour estimer le param√®tre
    statistique.

-   La **valeur p** (angl. p-value) est la probabilit√© d'observer un
    r√©sultat aussi extr√™me que celui obtenu dans l'√©chantillon sous
    l'hypoth√®se nulle. Elle est utilis√©e pour d√©terminer si le r√©sultat
    du test est statistiquement significatif en comparant sa valeur √† un
    seuil de signification pr√©d√©fini (habituellement 5% = 0.05). La
    p-value est calcul√©e √† partir de la statistique de test t et des
    degr√©s de libert√© associ√©s √† l'√©chantillon.

En pratique, c'est surtout la valeur p qui compte ! Dans notre cas, elle
est clairement sup√©rieure √† 5% ( \> 0.05), ce qui nous indique que la
diff√©rence du QI entre les √©tudiant-e-s et la population n'est PAS
significative (si nous utilisons des int√©rvalles de confiance de 95%) !

Cela veut dire que **nous ne pouvons PAS abondonner notre hypoth√®se
nulle H0** car il y a une forte probabilit√© que la diff√©rence de QI
observ√©e dans notre √©chantillon est le r√©sultat d'un pure hasard. En
d'autres termes, selon cet √©chantillon, nous ne pouvons pas conclure que
le QI des √©tudiant-e-s et significativement plus √©lev√© que celui de la
population g√©n√©rale.

```{r}
# Reg√©n√©rons encore une fois des donn√©es d'√©chantillon, mais cette fois-ci avec n = 50 observations 
set.seed(123)
scores_qi <- rnorm(50, mean = 105, sd = 15)

# Test t √† un √©chantillon
resultat_test_t <- t.test(scores_qi, mu = 100)
print(resultat_test_t)
```

La valeur p est maintenant beaucoup plus petite, soit inf√©rieure √† 1%
(\< 0.01). Cela nous indique que la diff√©rence entre le QI des
√©tudiant-e-s et de la population est significative (si nous utilisons
des intervalles de confiance de 95%) !

Avec un tel r√©sultat de test t, **nous pouvons rejeter l'hypoth√®se nulle
H0**, car la probabilit√© que les valeurs observ√©es soient le r√©sultat
d'un pure hasard sont tr√®s faible (moins de 1%). Nous pouvont alors
inf√©rer que le QI des √©tudiant-e-s est significativement plus √©lev√© que
celui de la population g√©n√©rale.

### Exercice 1

Selon l'√©tude [World Internet Project de l'Universit√© de
Zurich](https://doi.org/10.5167/uzh-251581), qui a √©valu√© les donn√©es
pour la Suisse, les personnes en Suisse ont pass√© en moyenne 5.6 heures
en ligne en 2023. Chez les 20-29 ans, ce chiffre s'√©l√®ve m√™me √† 7.9
heures en moyenne.

R√©alisez un test T en utilisant ces statistiques comme suit :

-   Simulez avec `rnorm()`30 valeurs pour l'utilisation d'Internet en
    heures par jour pour le groupe d'√¢ge 20-29 ans
    (`mean = 7.9, sd = 2`).

-   Testez si la dur√©e moyenne d'utilisation d'Internet en heures de
    votre √©chantillon simul√© de 30 suisses de 20 √† 29 ans se distingue
    significativement de la moyenne nationale (`mu = 5.6`).

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
# G√©n√©rons des donn√©es d'√©chantillon hypoth√©tique avec n = 30 observations 
set.seed(123)

usage_20_29 <- rnorm(30, mean = 7.9, sd = 2)

# Test t √† un √©chantillon
resultat_test_t <- t.test(usage_20_29, mu = 5.6)
print(resultat_test_t)
```

La tr√®s faible valeur p indique qu'il est extr√™mement improbable que
l'utilisation d'Internet des 20-29 ans ne diff√®re PAS significativement
de la moyenne nationale.

Nous pouvons alors rejeter H0.

En d'autres termes : Nous pouvons supposer avec une tr√®s grande
certitude que les 20-29 ans ont une utilisation d'Internet
significativement plus √©lev√©e que la moyenne de la population en Suisse.
:::

### Exemple 2 : test t √† deux √©chantillons

Utilisons encore une fois la fonction `rnorm()`, mais maintenant pour
simuler deux √©chantillons hypoth√©tiques :

-   Un √©chantillon de 5 tailles de femmes suisses

-   Un √©chantillon de 5 tailles d'hommes suisses

Selon l'article de [*24
heures*](https://www.24heures.ch/calculateur-en-ligne-quelle-taille-faites-vous-par-rapport-aux-autres-191558705635#),
qu'on a d√©j√† vu en classe, en Suisse, les femmes ont une taille moyenne
de 164.7 cm tandis que les hommes mesurent 177.4 cm en moyenne. Dans la
suite, nous supposons que les √©carts-types sont de +- 5.6 cm pour les
femmes et de +- 6.1 cm pour les hommes.

```{r}
# Donn√©es exemplaires :
set.seed(123)
tailles_f <- rnorm(5, mean = 164.7, sd = 5.6)
tailles_h <- rnorm(5, mean = 177.4, sd = 6.1)

# Two-sample t-test
t_test_two_sample <- t.test(tailles_f, tailles_h)
print(t_test_two_sample)

```

Comme nos √©chantillons de `n = 5` sont tr√®s petit, il se peut que la
diff√©rence de taille moyenne entre les suisses et les suissesses n'est
pa significative si on utilise des intervalles de confiances de 95% !
Cependant, d√®s que nous augmentons l'√©chantillon simul√©, par exemple √†
`n = 20` ou `n = 100`, le test T indique clairement que la diff√©rence de
taille est significative.

### Exercice 2

Supposons maintenant qu'un avion en provenance d'Am√©rique atterrisse √†
Gen√®ve-Cointrin. Il transporte une s√©lection de 24 joueuses de la
Women's NBA, la ligue professionnelle f√©minine de basket-ball aux
√âtats-Unis. Selon [les statistiques de la
WNBA](https://jokermag.com/average-height-wnba-players/), ces joueuses
mesurent en moyenne 184.5 cm.

Quelle est la probabilit√© que 24 hommes suisses choisis au hasard
mesurent √©galement cette taille en moyenne ? (Supposons que l'√©cart-type
des joueuses est de 6.5 cm).

::: {.callout-caution collapse="true"}
### Solution

```{r}
#| echo: true
#| output: true
# G√©n√©rons des donn√©es pour deux √©chantillons hypoth√©tique avec n = 24 observations chacun
set.seed(123)
tailles_f_WNBA <- rnorm(24, mean = 184.5, sd = 6.5)
tailles_h <- rnorm(24, mean = 177.4, sd = 6.1)

# Two-sample t-test
t_test_two_sample <- t.test(tailles_f_WNBA, tailles_h)
print(t_test_two_sample)
```

La tr√®s petite valeur p, inf√©rieure √† 1%, indique qu'il est extr√™mement
improbable que 24 hommes suisses tir√© au hasard sont environ de m√™me
taille que 24 joueuses de la WNBA. Nous pouvons alors rejeter H0. En
d'autres termes : Nous pouvons supposer avec une tr√®s grande certitude
que les joueuses de la WNBA sont significativement plus grande que les
hommes suisses moyens.
:::

√Ä noter : la fonction `t.test()`, comme on l'a utilis√© dans ces exemples
de code jusqu'√† pr√©sent, utilise plusieurs param√®tres par d√©faut, si
nous ne les sp√©cifions pas comme arguments dans la fonction. Voici
quelques-un de ces param√®tres, qu'on peut aussi visualiser avec
`?t.test()` :

```         
t.test(x, y = NULL,
       alternative = c("two.sided", "less", "greater"),
       mu = 0, paired = FALSE, var.equal = FALSE,
       conf.level = 0.95, ...)
```

En fonction de votre probl√©matique et de vos donn√©es, par exemple dans
un travail de bachelor, il peut √™tre n√©cessaire de sp√©cifier
explicitement certains de ces param√®tres. Pour ce faire, il peut √™tre
utile de lire les pages d'aide de R et de rechercher d'autres documents
en ligne pertinents pour votre probl√©matique sp√©cifique.

-   Un tutoriel qui approfondit le test t dans R est par exemple [celui
    de Datacamp
    (2024)](https://www.datacamp.com/tutorial/t-tests-r-tutorial).

{{< pagebreak >}}

# Session 12 \| Statistiques inf√©rentielles II

**Sujet : La statistique inf√©rentielle, Partie 2 (ANOVA et r√©gression
lin√©aire)**

## L'analyse de la variance (ANOVA)

::: {.callout-note icon="true"}
## √Ä noter

L'analyse de la variance (abbr√©g√©e **ANOVA**) est un ensemble de mod√®les
statistiques et de proc√©dures d'estimation associ√©es utilis√©s pour
analyser les diff√©rences entre les moyennes. L'ANOVA a √©t√© d√©velopp√©e
par le statisticien britannique [Ronald Fisher
(1890-1962)](https://fr.wikipedia.org/wiki/Ronald_Aylmer_Fisher).

L'ANOVA permet d'√©tudier le comportement d'une variable quantitative √†
expliquer en fonction d'une ou de plusieurs variables cat√©gorielles.¬†

Dans sa forme la plus simple, l'ANOVA fournit un test statistique
permettant de d√©terminer si deux moyennes de population ou plus sont
√©gales, et g√©n√©ralise donc le test t au-del√† de deux moyennes. En
d'autres termes, l'ANOVA est utilis√©e pour tester si les diff√©rences
entre deux ou plusieurs moyennes d'une variable quantitative √† expliquer
sont significatives ou si elles peuvent √™tre attribu√©es au hasard.

Le principe de l'ANOVA est bas√© sur la loi de la variance totale, selon
laquelle la variance observ√©e d'une variable particuli√®re est divis√©e en
composantes attribuables √† diff√©rentes sources de variation, telles que
la variation entre les groupes et la variation √† l'int√©rieur des
groupes.

En fonction du nombre de facteurs et du nombre de niveaux dans chaque
facteur, il existe diff√©rents types d'ANOVA, tels que l'ANOVA √† un
facteur, l'ANOVA √† deux facteurs, etc.

(Source : [Wikip√©dia,
2024](https://en.wikipedia.org/wiki/Analysis_of_variance)).
:::

::: {.callout-caution collapse="false"}
## Attention

Comme pour le test t, l'ANOVA n√©cessite certaines hypoth√®ses concernant
les donn√©es. Les observations de la variable √† expliquer doivent
notamment √™tre ind√©pendamment et identiquement distribu√©es
(approximativement une distribution normale) et la variance entre les
groupes doit √™tre similaire (homosc√©dasticit√©).
:::

Dans R, la **fonction `aov()`** est utilis√©e pour effectuer des ANOVAs √†
un ou plusieurs facteurs.

-   Elle prend en entr√©e une formule qui sp√©cifie la variable r√©ponse et
    les facteurs explicatifs, ainsi qu'un data frame contenant les
    donn√©es. Syntaxe : `aov(formula, data)`

-   La fonction `aov()` renvoie un objet de classe *aov* qui contient
    les r√©sultats de l'analyse de variance, y compris

    -   les sommes de carr√©s,

    -   les degr√©s de libert√©,

    -   les valeurs de F et

    -   les valeurs de p pour chaque effet du mod√®le.

En r√©sum√©, `aov()` est utilis√©e pour ajuster des mod√®les lin√©aires √†
effets fixes et pour effectuer des analyses de variance.

### Exemple 1 : ANOVA avec le jeu de donn√©es `palmerpenguins`

[![](images/palmerpenguins.png)](https://allisonhorst.github.io/palmerpenguins/index.html)

Pour cet exemple, il faut t√©l√©charger le paquet R `palmerpenguins`.
Celui-ci contient un jeu de donn√©es avec des informations sur trois
esp√®ces de pingouins (Ad√©lie, Chinstrap et Gentoo) qui vivent dans
l'archipel de Palmer en Antarctique.

Les donn√©es ont √©t√© collect√©es entre 2007 et 2009 et comprennent des
mesures telles que la longueur du bec (`bill_length_mm`), la longueur
des nageoires (`flipper_length_mm`), le poids corporel (`body_mass_g`)
et le sexe des pingouins.

-   Utilisez le code suivant pour la premi√®re installation du paquet :
    `install.packages("palmerpenguins")`

-   Apr√®s l'installation, il suffit d'activer le paquet avec
    `library(palmerpenguins)`

-   Il est toujours recommand√© de comprendre un nouveau jeu de donn√©es
    au niveau d√©scriptif, utilisez donc `?palmerpenguins` et naviguez un
    peu sur [le site des cr√©atrices de ce paquet
    R](https://allisonhorst.github.io/palmerpenguins/) !

-   Le **but de notre ANOVA** est de d√©terminer si les diff√©rences de
    longueur moyenne des nageoires `flipper_length_mm` entre les trois
    esp√®ces de pingouins sont statistiquement significatives.

    -   `flipper_length_mm` est donc notre variable quantitative √†
        expliquer et

    -   `species` est notre variable cat√©gorielle qui indique √† quelle
        esp√®ces de pingouins (Ad√©lie, Chinstrap et Gentoo) chaque
        observation de `flipper_length_mm` appartient.

```{r}
#| echo: true
#| output: true
#| warning: false

library(tidyverse)
library(palmerpenguins)

# Explorez d'abord un peu la structure du jeu de donn√©es
str(penguins)

# Visualisez les distributions de flipper length avec des boxplots
ggplot(penguins, aes(x = species, y = flipper_length_mm)) +
  geom_boxplot()

# Comme alternative, vous pouvez aussi cr√©ez un histogramme plus avanc√© pour comparer flipper length par esp√®ce
ggplot(data = penguins, aes(x = flipper_length_mm)) +
  geom_histogram(aes(fill = species), color = "black", alpha = 0.5, position = "identity", bins = 30) +
  scale_fill_manual(values = c("darkorange","darkorchid","cyan4")) +
  theme_minimal() +
  labs(title = "Histograms of flipper length by penguin species",
       subtitle = "n = 344 ; data source : palmerpenguin R package")

# Calculs des variances de flipper length avec dplyr par esp√®ce de pingouin, pour v√©rifier si l'hypoth√®se des variances similaire entre groupes est satisfaite :
penguins %>% 
  group_by(species) %>% 
  summarize(var_fl = var(flipper_length_mm, na.rm = TRUE))

# ANOVA avec aov()
anova_1 <- aov(flipper_length_mm ~ species, data = penguins)
summary(anova_1)

# √† noter, avec TukeyHSD() nous pouvons v√©rifier d'avantage les diff√©rence entre chaque paire de variables des trois groupe :
TukeyHSD(anova_1)

# Nous pouvons rejeter H0 avec une grande certitude !
```

## La r√©gression lin√©aire avec `lm()`

### Explications th√©oriques de la r√©gression lin√©aire

Dans le monde r√©el, nous supposons souvent qu'il existe des **relations
de cause √† effet**.

-   Par exemple, nous pouvons supposer que les personnes ayant un niveau
    d'√©ducation √©lev√© ont des salaires plus √©lev√©s. Il s'agit bien s√ªr
    d'une g√©n√©ralisation et il se peut qu'elle ne soit vraie qu'en
    moyenne (il se peut que certaines personnes ayant un tr√®s faible
    niveau d'√©ducation aient des salaires tr√®s √©lev√©s et vice versa).
    N√©anmoins, malgr√© quelques exceptions √† la r√®gle, nous pouvons
    raisonnablement supposer qu'en moyenne, une telle relation de cause
    √† effet entre le niveau d'√©ducation et le salaire existe.

La question suivante est donc de savoir quelle est l'ampleur d'un tel
effet et s'il est possible de le quantifier.

-   Est-il possible, par exemple, de pr√©dire une augmentation moyenne du
    salaire en % pour chaque ann√©e d'√©tudes suppl√©mentaire ? R√©pondre √†
    une telle question peut s'av√©rer compliqu√© pour diff√©rentes raisons.

-   Si l'√©ducation est importante, un certain nombre d'autres facteurs
    peuvent √©galement influencer le salaire d'une personne, tels que
    l'√¢ge, le sexe, l'origine, la classe sociale, l'intelligence, les
    capacit√©s de communication, la r√©sistance au stress et peut-√™tre
    m√™me la taille, l'attrait physique et l'attitude politique. Si ces
    autres facteurs ont √©galement une influence sur le salaire, comment
    d√©terminer l'impact fractionnel du niveau d'√©ducation ?

Un autre probl√®me, en particulier dans la pratique, est que nombre de
ces autres facteurs peuvent ne pas √™tre disponibles ou √™tre difficiles √†
mesurer.

-   Et m√™me si tous ces facteurs pouvaient √™tre observ√©s et contr√¥l√©s,
    la relation entre le niveau d'√©ducation et le salaire sera toujours
    soumise √† un certain degr√© de hasard. Peut-√™tre y a-t-il d'autres
    facteurs inconnus, ou peut-√™tre y a-t-il simplement une fluctuation
    inexplicable du niveau de salaire entre tous les individus, m√™me
    ceux qui ont des qualifications et des profils socio-√©conomiques
    tr√®s similaires.

Une solution possible pour quantifier n√©anmoins la relation de causalit√©
entre deux variables, telles que le niveau d'√©ducation et le salaire des
personnes, malgr√© ces incertitudes, est d'effectuer une **analyse de
r√©gression lin√©aire** !

::: {.callout-note icon="true"}
## √Ä noter

La r√©gression lin√©aire est une m√©thode statistique utilis√©e pour
mod√©liser la relation lin√©aire entre une **variable √† expliquer (y)** et
une ou plusieurs **variables explicatives (x1, x2, etc.)**.

-   La variable √† expliquer, y, est parfois aussi appel√©e **variable
    d√©pendante** ou **variable de r√©ponse** et, en anglais, **output
    variable**, **response variable**, **predicted variable**

-   Les variables explicatives, x, quant √† eux, sont aussi appel√©es
    **variables ind√©pendantes** ou **pr√©dicteurs** et, en anglais,
    **input variables**, **predictor variables**.

Nous parlons de r√©gression lin√©aire **simple**, si il y a seulement une
variable explicative x et de r√©gression lin√©aire **multiple** si il y a
plus d'une variable explicative, p. ex. x1, x2, x3, etc.
:::

En analyse de donn√©es, un mod√®le de r√©gression a deux principaux types
d'applications possibles :

-   **Explication (causale)** : Si nous supposons qu'il existe une
    relation causale entre y et x, nous pouvons expliquer les variations
    observ√©es de y en termes de variations observ√©es de x.

    -   Par exemple, consid√©rons un √©chantillon al√©atoire de donn√©es sur
        la taille et le poids des personnes. Nous pouvons supposer qu'en
        moyenne, les personnes plus grandes p√®sent plus que les
        personnes plus petites (relation de cause √† effet). Par
        cons√©quent, nous pourrions d√©velopper un mod√®le de r√©gression
        qui explique les variations de poids (y) en termes de variations
        de taille (x).

-   **Pr√©diction** : Si nous disposons d'un √©chantillon repr√©sentatif de
    donn√©es contenant des observations des valeurs y et x, nous pouvons
    adapter un mod√®le de r√©gression aux donn√©es. Par la suite, nous
    pouvons utiliser le mod√®le de r√©gression pour un nouvel ensemble de
    donn√©es qui ne contient que des valeurs x et pr√©dire les valeurs y
    correspondantes.

    -   Supposons par exemple que vous soyez un agent immobilier. Vous
        disposez d'un ensemble de donn√©es de 200 ventes de maisons dans
        une ville au cours des cinq derniers mois, qui contient le prix
        de vente (y) et la taille de la maison en m√®tres carr√©s (x).
        Vous pouvez maintenant adapter un mod√®le de r√©gression √† vos
        donn√©es et l'utiliser pour pr√©dire les prix de vente attendus
        des maisons actuellement sur le march√© en fonction de leurs
        superficie (x), que vous connaissez.

Notez qu'un mod√®le de r√©gression lin√©aire, comme tout mod√®le, est
toujours **une simplification de la r√©alit√©**. Par cons√©quent, la
pr√©cision des mod√®les de r√©gression lin√©aire appliqu√©s √† des donn√©es
r√©elles ne sera jamais de 100 %, c'est-√†-dire qu'elle est sujette √† une
erreur d'estimation.

Comprendre (et aussi quantifier) cette d√©viation du mod√®le de r√©gression
par rapport aux valeurs observ√©es est √©galement une √©tape importante de
toute analyse de r√©gression, comme nous le verrons par la suite.

Au niveau technique, l'objectif de la r√©gression lin√©aire est de
sp√©cifier une √©quation math√©matique, appel√©e **mod√®le de r√©gression**,
qui quantifie la relation entre les variables y et x sur la base d'un
ensemble d'observations.

Par exemple, dans le cas d'une r√©gression lin√©aire simple avec une
variable x, nous utiliserions l'√©quation suivante :

$$
y = \beta_0 + \beta_1 x + \epsilon
$$ o√π :

-   $y$ est la variable √† expliquer

-   $x$ est la variable explicative.

-   $\beta_0$ est l'ordonn√©e √† l'origine de la droite de r√©gression.

-   $\beta_1$ est la pente de la droite de r√©gression.

-   $\epsilon$ est le terme d'erreur al√©atoire

::: {.callout-note icon="true"}
## √Ä noter

Si cela est trop abstrait pour certaines personnes : Nous pourrions
√©galement dire que, d'un point de vue pratique, l'objectif d'une
r√©gression lin√©aire simple est d'ajuster une ligne droite √† un nuage de
points. Le mod√®le de r√©gression serait la droite de r√©gression qui
mod√©lise la relation entre les variables y et x (les observations sous
la forme d'un nuage de points).
:::

### La fonction `lm()`

La fonction **`lm()`** dans R est utilis√©e pour ajuster un mod√®le de
r√©gression lin√©aire. Elle est couramment utilis√©e dans le contexte de la
r√©gression lin√©aire pour √©tudier la relation entre une variable
d√©pendante (`y`) et une ou plusieurs variables ind√©pendantes (`x1`,
`x2`, etc.).

La syntaxe de base de la fonction `lm()` est la suivante :
**`lm(formula, data)`**.

-   L'argument `formula` d√©signe une formule qui d√©crit le mod√®le √†
    ajuster. Par exemple, `y ~ x1 + x2` signifie que la variable
    d√©pendante y est mod√©lis√©e en fonction des variables ind√©pendantes
    x1 et x2.

-   L'argument `data` requiert l'indication du jeu de donn√©es que la
    r√©gression doit utiliser en tant qu'entr√©e contenant les variables
    mentionn√©es dans la formule.

### Exemple 1 : La r√©gression lin√©aire √† une variable avec `mtcars`

Voici un exemple d'utilisation de la fonction `lm()` avec le jeu de
donn√©es `mtcars` : `lm(mpg ~ wt, data = mtcars)`

-   Notre but est de mod√©liser la relation entre la variable d√©pendante
    `mpg` (miles per gallon) et la variable ind√©pendante `wt` (weight).

-   Notre **hypoth√®se** est qu'il existe une relation n√©gative entre
    `wt` et `mpg` des v√©hicules dans `mtcars`. En d'autres termes, nous
    nous attendons √† ce que les voitures plus lourdes aient tendance √†
    parcourir moins de distance avec une unit√© de carburant que les
    voitures plus l√©g√®res.

-   Nous supposons qu'il s'agit d'une **relation de cause √† effet**, car
    les lois de la physique nous apprennent que l'acc√©l√©ration et le
    d√©placement d'objets plus lourds n√©cessitent une force et une
    √©nergie plus importantes. Par cons√©quent, nous supposons que les
    voitures plus lourdes consomment g√©n√©ralement plus d'√©nergie en
    forme de carburant que les voitures plus l√©g√®res.

```{r}
# Charger le jeu de donn√©es mtcars
data(mtcars)

# Ajuster un mod√®le de r√©gression lin√©aire avec mpg comme variable d√©pendante et wt comme variable ind√©pendante
modele_1 <- lm(mpg ~ wt, data = mtcars)

# Afficher le r√©sum√© du mod√®le que nous pouvons interpr√©ter
summary(modele_1)
```

Le r√©sultat de la r√©gression lin√©aire indique que le mod√®le lin√©aire
`modele_1` pr√©dit la variable d√©pendante `mpg` en fonction de la
variable ind√©pendante `wt`. Regardons le r√©sultat plus en detail :

-   Les coefficients du mod√®le sont pr√©sent√©s dans la section
    *Coefficients*.

    -   L'interception est estim√©e √† 37,285 et le coefficient pour `wt`
        est estim√© √† -5,345. Cela signifie que pour chaque augmentation
        d'une unit√© de `wt`, la valeur pr√©dite de `mpg` diminue de 5,345
        unit√©s en moyenne. En d'autres termes, pour chaque tranche de 1
        000 livres (environ 454 kg) de plus qu'une voiture p√®se, la
        valeur de sa consommation de carburant diminue de 5,345 miles.

    -   La valeur de p (Pr(\>\|t\|)) pour le coefficient de `wt` est
        tr√®s faible (\< 0,000000000129), ce qui indique que le
        coefficient est significativement diff√©rent de z√©ro et que la
        variable `wt` a un effet significatif sur la variable d√©pendante
        `mpg`.

-   La section *Residuals* indique les r√©sidus minimaux, du premier
    quartile, de la m√©diane, du troisi√®me quartile et maximaux. Ces
    valeurs peuvent √™tre utilis√©es pour v√©rifier si les hypoth√®ses du
    mod√®le sont satisfaites.

-   Le *Residual standard error* est l'√©cart type r√©siduel, qui mesure
    l'√©cart entre les valeurs pr√©dites et les valeurs r√©elles de la
    variable d√©pendante. Plus cette valeur est faible, mieux le mod√®le
    s'adapte aux donn√©es. Dans ce cas, la valeur est de 3,046.

-   Le *Multiple R-squared* est le coefficient de d√©termination, qui
    mesure la proportion de la variance de la variable d√©pendante
    expliqu√©e par la variable ind√©pendante. Dans ce cas, le coefficient
    de d√©termination est de 0,7528, ce qui indique que la variable `wt`
    explique environ 75,28% de la variance de la variable `mpg`. Pour un
    mod√®le de r√©gression ne comportant qu'une seule variable, il s'agit
    d'une valeur exceptionnellement √©lev√©e. Cela signifie que les
    variations de la consommation de carburant d'une voiture √† l'autre
    s'expliquent dans une tr√®s large mesure par les diff√©rences de poids
    !

-   Le *Adjusted R-squared* est une mesure de la proportion de la
    variance de la variable d√©pendante qui est expliqu√©e par les
    variables ind√©pendantes dans un mod√®le de r√©gression lin√©aire, tout
    en tenant compte du nombre de variables ind√©pendantes dans le
    mod√®le. Il est calcul√© en ajustant le R-squared en fonction du
    nombre de variables ind√©pendantes dans le mod√®le, et est toujours
    inf√©rieur ou √©gal au R-squared. Un mod√®le avec un coefficient de
    d√©termination ajust√© plus √©lev√© est consid√©r√© comme un meilleur
    mod√®le, car il explique une plus grande proportion de la variance de
    la variable d√©pendante tout en utilisant un nombre raisonnable de
    variables ind√©pendantes.

-   Enfin, la *F-statistic* est utilis√©e pour tester l'hypoth√®se nulle
    que le coefficient de r√©gression est √©gal √† z√©ro. Dans ce cas, la
    valeur de p associ√©e √† la statistique F est tr√®s faible (\<
    0,0000000001294), ce qui indique que l'hypoth√®se nulle peut √™tre
    rejet√©e et que le mod√®le est significatif.

La vid√©o YouTube suivante de StatQuest, un cr√©ateur de contenus qui
explique tr√®s bien lest concepts statistiques (en anglais), d√©crit
comment interpr√©ter les r√©sultats d'une regression lin√©aire dans R :

<iframe width="560" height="315" src="https://www.youtube.com/embed/u1cc1r_Y7M0?si=TBPst3RY5jKWxIyu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>

</iframe>

**Les graphiques de diagnostic**

Les graphiques de diagnostic (angl. diagnostic plots) sont des
graphiques utilis√©s pour √©valuer la qualit√© d'un mod√®le de r√©gression
lin√©aire et v√©rifier si les hypoth√®ses du mod√®le sont satisfaites (p.
ex. si les variables suivent approximativement une loi normale).

En utilisant la fonction `plot()` apr√®s avoir calcul√© un mod√®le de
r√©gression lin√©aire dans R, nous pouvons visualiser quatre types de
plots diagnostiques :

```{r}
# Cette commande fait en sorte que les graphes de diagnostic soient tous affich√©s en m√™me temps, sur un panneau 2 X 2 :
par(mfrow=c(2,2)) 

# Afficher ensuite les graphiques de diagnostic :
plot(modele_1)
```

**Explications des quatre graphiques diagnostiques** :

1.  **Residuals vs Fitted** : Ce graphique montre si les r√©sidus (la
    distance entre les valeurs mod√©lis√©es et observ√©es) pr√©sentent des
    tendances non lin√©aires. Il peut y avoir une relation non lin√©aire
    entre les variables explicatives x et une variable expliqu√©e y, et
    le sch√©ma peut appara√Ætre dans ce graphique si le mod√®le ne capture
    pas la relation non lin√©aire. Si vous trouvez des r√©sidus plus ou
    moins uniform√©ment r√©partis (approxim√©s par la ligne rouge) autour
    de la ligne horizontale en pointill√©s sans tendances distinctes,
    c'est une bonne indication que vous n'avez pas de relations non
    lin√©aires.

2.  **Q-Q Residuals** : Ce graphique montre si les r√©sidus (les points)
    suivent une loi normale. Les r√©sidus se situent-ils plus ou moins
    sur la ligne droite diagonale en pointill√©s ou s'en √©cartent-ils
    fortement ? C'est une bonne chose si les r√©sidus sont bien align√©s
    sur la ligne droite en pointill√©s.

3.  **Scale-Location** : Ce graphique affiche les valeurs ajust√©es d'un
    mod√®le de r√©gression sur l'axe des abscisses et la racine carr√©e des
    r√©sidus standardis√©s sur l'axe des ordonn√©es. C'est ainsi que vous
    pouvez v√©rifier l'hypoth√®se de variance √©gale (homosc√©dasticit√©).
    C'est une bonne chose si vous voyez une ligne rouge plus ou moins
    horizontale avec des points r√©partis de mani√®re √©gale (au hasard)
    autour d'elle.

4.  **Residuals vs Leverage** : Ce graphique permet d'identifier les
    valeurs aberrantes influentes (valeurs extr√™mes) dans les donn√©es
    qui peuvent affecter le mod√®le de r√©gression lin√©aire. Toutes les
    valeurs aberrantes ne sont pas n√©cessairement influentes ; certaines
    peuvent ne pas avoir d'impact significatif sur le mod√®le de
    r√©gression, ce qui signifie que les r√©sultats de l'analyse de
    r√©gression restent similaires, que ces cas soient inclus ou exclus.
    Cependant, certaines valeurs aberrantes peuvent avoir une grande
    influence et modifier les r√©sultats si elles sont exclues, car elles
    ne s'alignent pas sur la tendance g√©n√©rale. Dans ce graphique, nous
    nous concentrons sur les valeurs aberrantes situ√©es dans les coins
    sup√©rieurs ou inf√©rieurs droits, en dehors des lignes pointill√©es,
    qui indiquent des scores √©lev√©s de ¬´ distance de Cook ¬ª. Ces cas ont
    un impact significatif sur les r√©sultats de la r√©gression et doivent
    √™tre not√©s.

En examinant ces graphiques de diagnostic, nous pouvons √©valuer si les
hypoth√®ses du mod√®le de r√©gression lin√©aire sont satisfaites, telles que
l'ind√©pendance des r√©sidus, l'homosc√©dasticit√©, la lin√©arit√© et la
normalit√© des r√©sidus.

Si les graphiques de diagnostic montrent que les hypoth√®ses ne sont pas
satisfaites, cela peut indiquer que le mod√®le n'est pas ad√©quat et
qu'une transformation des donn√©es ou une s√©lection de variables
diff√©rente peut √™tre n√©cessaire.

Dans le cas sp√©cifique du mod√®le de r√©gression `modele_1`, qui mod√©lise
`mpg ~ wt` dans le jeu de donn√©es `mtcars`, les graphique de diagnostic
sont tout √† fait acceptable.

### Exemple 2 : La r√©gression lin√©aire multiple avec `mtcars`

Pouvons-nous encore am√©liorer `modele_1` qui pr√©dit `mpg` dans le jeu de
donn√©es mtcars ? Une possibilit√© √©vidente est d'inclure d'autres
variables x, en plus de `wt`, dans notre mod√®le de r√©gression pour
pr√©dire `mpg`.

En d'autres termes, nous devrions effectuer une r√©gression lin√©aire
multiple !

Si nous v√©rifions √† nouveau les variables de mtcars (par exemple, avec
`?mtcars`), une autre variable nous saute aux yeux qui pourrait avoir un
impact sur `mpg` : la variable `hp`, qui indique la puissance brute en
chevaux des voitures.

Nous pouvons raisonnablement supposer une relation causale : que les
voitures avec plus de chevaux, c'est-√†-dire avec des moteurs plus
puissants, consomment plus de `mpg` que les voitures avec moins de `hp`.

```{r}
# Ajuster un mod√®le de r√©gression lin√©aire multiple avec mpg comme variable d√©pendante et wt et hp comme variables ind√©pendantes
modele_2 <- lm(mpg ~ wt + hp, data = mtcars)

# Afficher le r√©sum√© du mod√®le que nous pouvons interpr√©ter
summary(modele_2)

# Afficher les graphiques de diagnostic
par(mfrow=c(2,2))
plot(modele_2)
```

Les r√©sultats montrent qu'en effet, la puissance en chevaux `hp` a
√©galement un effet n√©gatif sur `mpg`. La valeur p de `hp` indique un
effet significatif au niveau de 1% (mais pas au niveau de 0,1% comme
pour `wt`).

Le R-carr√© de notre mod√®le a √©galement augment√© pour atteindre 82,68%
(R-carr√© ajust√© √† 81,48%), ce qui est une valeur tr√®s √©lev√©e. Cela
signifie que `modele_2` peut effectivement expliquer une plus grande
partie de la variabilit√© de `mpg` que `modele_1`. N√©anmoins, parce qu'il
utilise plus de variables, le `modele_2` est aussi plus complexe. Cela
se traduit par une statistique F (69.21) plus faible pour `modele_2` que
pour `modele_1` (statistique F = 91,38).

Une question est alors : **comment choisir le meilleur mod√®le de
regression ?**

### Exemple 3 : La r√©gression par √©tape avec `mtcars`

Une possible solution est d'utiliser ce qu'on appelle **la r√©gression
par √©tape**. C'est une m√©thode d'ajustement des mod√®les de r√©gression
dans laquelle le choix des variables pr√©dictives est effectu√© par une
proc√©dure automatique.

Dans R, la r√©gression par √©tapes peut √™tre effectu√©e √† l'aide de
diff√©rentes approches, notamment la fonction `step()`, qui base ses
s√©lections sur les valeurs AIC (crit√®re d'information d'Akaike).

-   Pour notre exemple de r√©gression par √©tapes, nous allons pr√©dire
    `mpg` en utilisant toutes les autres variables de l'ensemble de
    donn√©es `mtcars`.

-   A partir de ce ¬´ mod√®le complet ¬ª, nous utiliserons ensuite une
    proc√©dure qui √©liminera les variables qui ne contribuent pas de
    mani√®re significative √† expliquer la variation de `mpg`.

-   La proc√©dure continuera √† √©liminer des variables jusqu'√† ce qu'un
    optimum soit atteint, c'est-√†-dire un mod√®le qui a un pouvoir
    explicatif suffisant (montr√© par sa valeur R-carr√©) mais qui n'est
    pas trop complexe (ou suradapt√©) avec trop de variables (ceci est
    d√©cid√© sur la base de la m√©trique AIC, **qui va √™tre minimis√©e** par
    la proc√©dure).

-   La bonne nouvelle, c'est que R produira le mod√®le optimal pour nous
    !

Voyons comment √ßa marche avec du code R !

```{r}
# Il faut √©ventuellement d'abord installer le paquet stats
# install.packages("stats")
library(stats)

# Cr√©ons le mod√®le complet avec toutes le variables de mtcars (avec ~ .)
full_model <- lm(mpg ~ ., data = mtcars)
summary(full_model)

# Nous utilisons la fonction step(), en commen√ßant par le mod√®le complet et en permettant √† la fois la s√©lection en amont et l'√©limination en aval sur la base de l'AIC (avec direction = "both")
stepwise_model <- step(full_model, direction = "both")
```

Voici comment la r√©gression par √©tape choisit le meilleur mod√®le :

-   **AIC le plus faible** : le mod√®le ayant l'AIC le plus faible est
    g√©n√©ralement pr√©f√©r√© car il sugg√®re un meilleur ajustement du mod√®le
    compte tenu du nombre de variables explicatives utilis√©es. L'AIC
    permet d'√©quilibrer l'ad√©quation et la complexit√© du mod√®le. Dans
    notre exemple, le mod√®le optimal retenu est donc
    `mpg ~ wt + qsec + am`.

Apr√®s avoir ex√©cut√© la r√©gression par √©tape, le r√©sum√© de
`stepwise_model` affiche les coefficients pour chaque variable
explicative ainsi que des statistiques telles que le R-carr√©, la
statistique F et les valeurs p pour les variables explicatives.

```{r}
summary(stepwise_model)
```

**Graphiques de diagnostic** : Apr√®s avoir choisi un mod√®le, il est
utile de v√©rifier les graphiques des r√©sidus pour valider les hypoth√®ses
d'homosc√©dasticit√©, de normalit√© et d'ind√©pendance des r√©sidus :

```{r}
par(mfrow=c(2,2))
plot(stepwise_model)
```

Les graphiques de diagnostic sont acceptable pour notre mod√®le !

### Ressources pour aller plus loin

Je vous recommande de jeter un coup d'≈ìil √† d'autres vid√©os YouTube de
StatQuest qui expliquent clairement les concepts statistiques, dont
beaucoup sont tr√®s pertinents pour les sciences sociales et pour vos
√©tudes en g√©n√©ral, p. ex. :

-   [Linear Regression, Clearly
    Explained!!!](https://youtu.be/nk2CQITm_eo?si=rtNUDxVBeq6D7xkr)
-   [Multiple Regression in R,
    Step-by-Step!!!](https://youtu.be/mno47Jn4gaU?si=PDMYDHu1ANTV70V2)
-   [The Normal Distribution, Clearly
    Explained!!!](https://youtu.be/rzFX5NWojp0?si=A10LmX2WJ1mbN46c)
-   [p-values: What they are and how to interpret
    them](https://youtu.be/vemZtEM63GY?si=SO9AOuuRMhDch-yk)
-   [R-squared, Clearly
    Explained!!!](https://youtu.be/2AQKmw14mHM?si=gN5HL80pFAi_R0CM)
-   [Hypothesis Testing and The Null Hypothesis, Clearly
    Explained!!!](https://youtu.be/0oc49DyA3hU?si=gH4KNuhTOYtnGoZU)
-   [Logistic Regression in R, Clearly
    Explained!!!](https://youtu.be/C4N3_XJJ-jU?si=2MPycgEfuUTQMaRa)

### Devoir pour Session 13 (Problem Set 4) et infos sur la session 14

-   La semaine prochaine, les 22 et 23 mai, **le Problem Set 4** aura
    lieu pendant la session 13. Son contenu sera ax√© sur les
    statistiques descriptives et inf√©rentielles (contenu des sessions
    10, 11 et 12).
-   Attention, **la session 14 du 29 et 30 mai 2024 sera une session en
    auto-apprentissage !** Il n'y a donc pas d'enseignement en classe √†
    Fribourg.La session 14 vous fournira surtout des ressources R plus
    avanc√©es que vous pourrez utiliser plus tard, par exemple pendant
    votre travail de bachelor, pour vos analyses empiriques.

{{< pagebreak >}}

# Session 13 (Problem Set 4)

Les r√©sultats du **Problem Set 4** (bonnes r√©ponses, √©chelle des notes)
sont acc√©ssibles sur la page Moodle de l'exercice.

::: {.callout-important title="Important"}
**Sp√©cificit√© du Problem Set 4** : les √©tudiant-e-s qui ont r√©pondu dans
les temps au questionnaire sur l'utilisation des m√©dias se voient
attribuer 2 points bonus suppl√©mentaires √† leur score dans le Problem
Set 4. Ces 2 points bonus, obtenus par une majorit√© d'√©tudiant-e-s, sont
pris en compte pour le calcul final de la note du cours (ils ne sont
toutefois pas comptabilis√©s dans l'histogramme ci-dessous).
:::

Voici l'histogramme des points obtenus par n = 71 √©tudiant-e-s qui ont
particip√© au Problem Set 4.

-   Le nombre maximal de points √©tait de 20, il fallait 10 pour passer
    le test.

-   La moyenne des points obtenus √©tait de 11.

-   47 √©tudiant-e-s (66%) ont r√©ussi Problem Set 4.

```{r}
#| echo: false
#| output: true
#| warning: false
# script pour faire un histogramme des points obtenus dans le Problem Set 4
# cours : Exercices M√©thodes II
# date : 22/23 mai 2024
# auteur : Julian Maitra

library(tidyverse)

# Adaptez le code suivant pour votre r√©pertoire de travail :

setwd("/Users/domus_julian/Documents/GitHub/intro-a-R/code")

# Enregistrez le fichier CSV points_ps_2 dans votre r√©pertoire de travail, 
# puis importez les donn√©es dans R (modifiez le code suivant selon votre ordinateur) :

points_ps_4 <- read.csv("~/Documents/GitHub/intro-a-R/code/pps_4.csv", encoding="UTF-8")

points_ps_4 <- points_ps_4 %>% filter(pps_4 > 0)

#points_ps_2 # il y a 71 observations de trois variables : √©tudiant-e, groupe et points

hist_ps_4 <-ggplot(points_ps_4, 
                   aes(x=pps_4)) + 
  geom_histogram(binwidth = 1, color="black", fill="white") +
  labs(title = "Histogramme des points obtenus dans le PS 4", # labs() permet de d√©finir plusieurs labels en m√™me temps (titre, axes, etc.)
       subtitle = "n = 71 r√©sultats de test", 
       caption = "Source des donn√©es : Moodle") +       
  xlab("Points obtenus") +                             
  ylab("Fr√©quence") + 
  theme_minimal() +
  coord_cartesian(xlim = c(0,20), ylim = c(0,14)) +
  scale_x_continuous(breaks = seq(0,20, by=1)) +
   scale_y_continuous(breaks = seq(0,14, by=2)) +
  geom_vline(aes(xintercept=9.5),
             color="red",  linewidth=1, linetype="dashed")
hist_ps_4
```

{{< pagebreak >}}

# Session 14 (en auto-apprentissage)

**Continuez √† am√©liorer votre ma√Ætrise de R en sciences de la
communication**

Voici des √©tapes cl√©s pour devenir un¬∑e utilisateur¬∑trice avanc√©¬∑e de R.

### Pratique r√©guli√®re

-   Il est essentiel de pratiquer r√©guli√®rement pour devenir plus √†
    l'aise avec R.

-   Int√©grez l'utilisation de R dans vos projets acad√©miques et
    personnels autant que possible.

### Application acad√©mique

-   Demandez aux enseignant-e-s d'autres cours si vous pouvez utiliser R
    dans leurs cours.

-   Proposez d'utiliser R pour l'analyse de donn√©es dans vos travaux de
    s√©minaire et de Bachelor.

-   Collaborez avec d'autres √©tudiant-e-s utilisateurs¬∑trices de R sur
    des projets de recherche en groupe √† l'universit√©.

### MOOC

Pour r√©p√©ter et approfondir vos connaissances en R, des **MOOC**
(massive open online courses) sont disponibles gratuitement en tant
qu'auditeur/auditrice (apr√®s inscription) :

1.  **Datacamp**: Introduction to R
    (4h):¬†<https://www.datacamp.com/courses/free-introduction-to-r>

2.  **Edx (Harvard)**: R Basics
    (8-16h):¬†<https://www.edx.org/course/data-science-r-basics>

3.  **Edx (Stanford)**: R Programming Fundamentals
    (12-18h):¬†<https://www.edx.org/course/r-programming-fundamentals>

4.  **Coursera**: Data Analysis with R Programming
    (37h):¬†<https://www.coursera.org/learn/data-analysis-r>

5.  **Udacity**: Data Analysis with R (2
    months):¬†<https://www.udacity.com/course/data-analysis-with-r--ud651>

Si vous payez entre 50 et 200 USD, il est √©galement possible de valider
de tels MOOC avec un certificat. Ces certificats peuvent notamment √™tre
reli√©s √† LinkedIn et y √™tre affich√©s.

### Tutoriels sur Youtube

Il existe √©galement de nombreux tutoriels R sur Youtube. Il peut s'agir
de cours R complets de diff√©rents niveaux ou de courtes vid√©os montrant
comment utiliser une technique R particuli√®re (par ex. un certain type
de visualisation).

1.  **Introduction √† R et RStudio (ft. mon chat radioactif) :** Tutoriel
    facile √† comprendre en fran√ßais d'environ 1h par le chercheur belge
    Nathan Uyttendaele (Il aborde certains aspects et logiciels que nous
    ne traitons pas dans notre cours. Mais dans l'ensemble, c'est une
    bonne introduction √† R et RStudio pour les d√©butants)
    :¬†<https://www.youtube.com/watch?v=sav3Mbe0_DM>

2.  **Introduction to R & RStudio and other videos on Data Analysis with
    R**¬†by Wouter van Atteveldt (computational communication scientist,
    VU Amsterdam)
    :¬†<https://www.youtube.com/watch?v=PVhZD5MINYM&list=PLjXODJ_lGN_V2ntvV2CN_GvzZ6Qm5km9L>

3.  **Boot Camp of the Summer Institute in Computational Social
    Science**, SICSS, taught by Chris Bail from Duke University
    (multiple videos, social science focus)
    :¬†<https://sicss.io/boot_camp/>

4.  **R Programming Tutorial: Learn the basics of statistical
    computing**¬†(by Barton Poulson, 2h comprehensive general R
    introduction) :¬†<https://www.youtube.com/watch?v=_V8eKsto3Ug>

### Intelligence artificielle pour coder

Utiliser l'intelligence artificielle g√©n√©rative pour coder. Jouez avec,
demandez simplement du code R pour faire certaines choses. Ces
interfaces peuvent vous fournir du code pr√™t √† l'emploi, que vous pouvez
copier et coller directement dans RStudio !

-   [ChatGPT](https://chatgpt.com)

-   [Le Chat de Mistral](https://chat.mistral.ai/chat)

### Communaut√©s en Ligne

Participez √† des communaut√©s en ligne pour rester connect√©¬∑e avec les
derni√®res tendances et partager vos connaissances :

-   [GitHub](https://github.com) : Le r√©seau social des d√©veloppeurs
-   [Stackoverflow](https://stackoverflow.com) : Un forum d'entraide
    pour programmeurs
-   [Kaggle](https://www.kaggle.com) : Une plateforme pour le machine
    learning et l'analyse de donn√©es

### Lecture sp√©cialis√©e

Approfondissez vos connaissances en R avec des livres num√©rique
open-source :

-   **R for Data Science** \[anglais\] Une r√©f√©rence bien √©tablie en
    sciences des donn√©es avec R par Wickham & Grolemund (2023, 2e √©d.) :
    [https://r4ds.hadley.nz/](https://r4ds.hadley.nz)

-   **R Cookbook** \[anglais\] R√©f√©rence √©tablie pour l'introduction,
    les statistiques et les graphiques avec R par Long & Teetor (2019,
    2e √©d.) :¬†<https://rc2e.com/>

-   **R Graphics Cookbook** \[anglais\] Ouvrage de r√©f√©rence pour
    concevoir des graphiques attrayants avec R¬†(2022, 2e √©d.), by Chang
    :¬†<https://r-graphics.org/>

-   **Introduction √† la programmation R**¬†par Goulet (2016, 5e √©d.) de
    l‚ÄôUniversit√©
    Laval¬†:¬†<https://cran.r-project.org/doc/contrib/Goulet_introduction_programmation_R.pdf>

### Valorisation des Comp√©tences

-   Mettez en avant vos comp√©tences en programmation R dans votre CV et
    sur LinkedIn, notamment les certificats obtenus via des MOOCs.

Ces conseils vous aideront √† utiliser efficacement R dans le domaine des
sciences de la communication et √† d√©velopper une expertise approfondie.

### Au revoir et √† bient√¥t

Ainsi se termine ce cours et donc l'introduction √† R dans le cadre des
Exercices M√©thodes II du [Bachelor en sciences de la communication √†
l'Universit√© de
Fribourg](https://www.unifr.ch/dcm/fr/etudes/bachelor/bachelor-fr-communication-medias/)
!

J'esp√®re que vous avez appris beaucoup de choses, notamment des
techniquesqui vous seront utiles pour la suite de vos √©tudes ! üí™ üòé

Et n'oubliez pas qu'au final, il faut surtout faire preuve de bon sens
pour comprendre comment des comp√©tences comme la programmation R peuvent
√™tre utilis√©es au mieux pour √©tudier des ph√©nom√®nes int√©ressants en
sciences de la communication ! üòÑ

*Julian Maitra, Fribourg, 30 mai 2024.*

**FIN DU COURS**
