---
title: "Exercices M√©thodes II"
date: 2024-02-22
author:
  - name: Julian Maitra
    orcid: 0000-0003-3989-5158
    email: julian.maitra@unifr.ch
    affiliation: 
      - name: Universit√© de Fribourg
        url: https://www.unifr.ch/home/en/
license: "MIT"
copyright: 
  holder: Julian Maitra
  year: 2024
format: html
editor: visual
toc: true
toc-depth: 2
toc-location: left
toc-title: Table des mati√®res
---

# Session 1

```{r}
#| echo: false
#| output: false
library(formatR)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
```

Bienvenue dans la premi√®re le√ßon du cours **Exercices M√©thode II** du
Bachelor en sciences de la communication √† l'Universit√© de Fribourg !

Sur cette page, je vous guiderai dans vos premiers pas avec R.

R est un langage de programmation open-source qui vous permet d'analyser
et de visualiser des donn√©es sur des ph√©nom√®nes de communication
int√©ressants.

Pour utiliser R sur votre ordinateur portable, vous devez d'abord
installer les deux logiciels suivants :

1.  le langage de programmation [R](https://cran.r-project.org)
2.  l'interface [RStudio](https://posit.co/download/rstudio-desktop/)

Notez que nous n'√©crirons le code R que dans RStudio, l'interface. Le
langage de programmation R doit d'abord √™tre install√©, mais il
fonctionnera ensuite en arri√®re-plan. Il n'est donc pas n√©cessaire
d'ouvrir R directement par la suite.

## L'interface RStudio

![Volets RStudio [Source :
posit.co](https://docs.posit.co/ide/user/ide/guide/ui/ui-panes.html)](https://docs.posit.co/ide/user/ide/guide/ui/images/rstudio-panes-labeled.jpeg)

Dans RStudio, il existe quatre volets diff√©rents :

1.  Le volet **source**
2.  Le volet **console**
3.  Le volet **environnement**
4.  Le volet **output**

## Ex√©cuter un script R

Nous travaillons principalement dans le volet **source**, c'est l√† que
nous √©crivons notre code.

Vous pouvez ouvrir le volet source en cr√©ant un nouveau **R script**
(cliquez sur le signe plus vert dans le coin sup√©rieur gauche). Vous
pouvez r√©√©crire ou copier-coller le calcul simple suivant et l'ins√©rer
dans votre script :

```{r}
#| echo: true
#| output: false
10+14
```

Une fois que nous avons √©crit du code R dans le script, nous pouvons
**l'ex√©cuter** en le s√©lectionnant et en cliquant sur le bouton
d'ex√©cution situ√© au-dessus du volet source (le bouton d'ex√©cution avec
la fl√®che verte √† qui montre √† droite).

C'est alors dans le volet de la **console** o√π le r√©sultat va √™tre
affich√© :

```{r}
#| echo: false
#| output: true
10+14
```

Notez que le nombre entre crochets indique la ligne du r√©sultat. Ici, il
s'agit de 1 car il n'y a qu'une seule ligne.

Voici quelques autres calculs simples, suivi de leurs r√©sultats :

```{r}
#| echo: true
#| output: true
1+2
99-98
2*10
100/2

2^10
```

::: {.callout-tip title="Astuce"}
Pour ex√©cuter le code R plus rapidement, vous pouvez placer votre
curseur sur une ligne de code √† ex√©cuter et utiliser les raccourcis
clavier suivants :

-   Sur **Windows** : <kbd>CTRL</kbd> + <kbd>Enter</kbd>

-   Sur **MacOS** : <kbd>Command</kbd> + <kbd>Enter</kbd>
:::

## Commenter votre code avec un `#`

C'est une bonne pratique de **commenter** son code R. Les commentaires
expliquent ce que le code fait et facilite l'utilisation ult√©rieure et
aussi le partage de code entre personnes (qui ne savent peut-√™tre pas ce
que vous vouliez faire avec votre code).

On commente en ajoutant un symbole **`#`** au d√©but de la ligne de code,
comme ceci :

```{r}
# Ceci est un commentaire, et R l'ignorera lors de l'ex√©cution du script.
```

## L'op√©rateur d'affectation `<-`

L'op√©rateur d'affectation **`<-`** est un op√©rateur cl√© de la
programmation R. Il permet d'attribuer des valeurs aux variables.

```{r}
#| echo: true
# Par exemple, nous pouvons attribuer la valeur 5 √† la variable x :
x <- 5
```

Si vous ex√©cutez ce code, une nouvelle variable, `x`, sera cr√©√©e dans le
volet **environnement** en haut √† droite de RStudio.

::: {.callout-note icon="true"}
## √Ä noter

En g√©n√©ral, la programmation R parle aussi d'**objets**, ou de
**structures de donn√©es**, que vous pouvez cr√©er. C'est pourquoi R est
√©galement appel√© **langage de programmation orient√© objet**. Les
variables √† un √©l√©ment sont des objets tr√®s simples. Au cours de ce
cours, nous d√©couvrirons d'autres types d'objets.
:::

::: {.callout-tip title="Astuce"}
Vous pouvez cr√©er l'operateur d'affectation `<-` avec les raccourcis
clavier suivants :

-   Sur **Windows** : <kbd>Alt</kbd> + <kbd>-</kbd>

-   Sur **MacOS** : <kbd>Option</kbd> + <kbd>-</kbd>
:::

## Variables √† √©l√©ment unique

Vous pouvez **imprimer** (afficher) la valeur d'une variable que vous
avez cr√©√©e, telle que `x`, en tapant le nom de la variable et en
l'ex√©cutant.

```{r}
#| echo: true
x
```

::: {.callout-important title="Important"}
-   Veillez toujours √† ex√©cuter votre code pour cr√©er des variables
    avant de les utiliser pour d'autres op√©rations. Si vous oubliez de
    cr√©er les variables en premier, vous obtiendrez une erreur comme
    r√©sultat.
:::

Par exemple, essayez d'ex√©cuter ce qui suit : `y + z`

Pourquoi cela cr√©e une erreur ? R√©ponse : les variables `y` et `z` n'on
pas encore √©t√© d√©finies !

Pour √©liminer l'erreur, nous devons donc d√©finir `y` et `z`.

```{r}
#| echo: true
#| output: true
y <- 7
z <- 3 

# Essayons encore une fois :
y + z
```

Maintenant √ßa marche ! üòÄ

::: {.callout-important title="Important"}
-   Sachez aussi que si vous attribuez une nouvelle valeur √† une
    variable existante, l'ancienne valeur sera √©cras√©e !
:::

```{r}
#| echo: true
# Notez que si vous ex√©cutez toutes les lignes de code suivantes, la variable x se voit attribuer la derni√®re valeur ex√©cut√©e : 4. Les valeurs 5 et 100 sont ecras√©es lors de l'ex√©cution du code.
x <- 5
x <- 100
x <- 4
x
```

### Les diff√©rents types de variable : num√©riques, textuelles et logique

Jusqu'√† pr√©sent, nous avons cr√©√© des variables de **type num√©rique**,
telles que `x` (valeur = 5).

Cependant, ce n'est pas le seul type de variable dans R.

::: {.callout-note icon="true"}
## √Ä noter

Dans R, il existe diff√©rents types de variables :

-   les variables **num√©riques**

-   les variables **textuelles**, √©galement appel√©es *character strings*
    (cha√Ænes de caract√®res).

-   les variables **logiques** avec les valeurs TRUE et FALSE (VRAI et
    FAUX)
:::

```{r}
#| echo: true
# Regardons quelques exemples avec du code ! (faut tout ex√©cuter !)

# variables num√©riques :
a <- 100
b <- 77

age <- 21
Insta_likes <- 1539

# variables textuelles (toujours ajouter des guillemets !)
c <- "chien"
d <- "chat"

Comm_TikTok <- "wsh"
Moliere <- "il n‚Äôest rien d‚Äô√©gal au tabac : c‚Äôest la passion des honn√™tes gens"

# variables logiques :

e <- TRUE
f <- FALSE
```

Les variables logiques peuvent √™tre utiles quand vous travaillez avec
des **cat√©gories binaires**.

Par exemple : il est souvent utile de classer les personnes ayant
r√©pondu √† un questionnaire en cat√©gories binaires, telles que :

-   homme/femme

-   mineur/majeur

-   conservateur/lib√©ral

-   etc.

```{r}
#| echo: true
# Si Marc √©tait mineur et Claire majeure, nous les classerions comme suit : 

Marc <- FALSE
Claire <- TRUE

# Dans cet exemple, la variable logique indique si une personne est majeure (TRUE) ou pas (FALSE)

```

## Variables √† plusieurs √©l√©ments : vecteurs

Les **vecteurs** constituent un autre type de variable (ou type d'objet)
essentiel dans la programmation R. Il s'agit de variables comportant
**plusieurs** √©l√©ments.

Vous pouvez cr√©er des vecteurs avec l'operateur d'affectation `<-` et la
**fonction de concatenation** `c()`.

```{r}
#| echo: true
# Voici quelques exemples avec du code ! (faut tout ex√©cuter !)

# un vecteur num√©rique (notez qu'il faut toujours s√©parer les valeurs avec des virgules)
v1 <- c(1, 2, 3)
```

Vous pouvez afficher la valeur de `v1` en tappant son nom et l'ex√©cutant
:

```{r}
#| echo: true
v1 
```

::: {.callout-note icon="true"}
## √Ä noter

En R, une **fonction** est un morceau de code con√ßu pour effectuer une
t√¢che sp√©cifique, souvent avec des param√®tres variables. Ces param√®tres
d'entr√©e sont √©galement appel√©s les **arguments** de la fonction.
:::

Prenons l'exemple de la fonction `c()` qui cr√©e des vecteurs :

-   les arguments de cette fonction doivent √™tre ins√©r√©s entre les
    crochets sous la forme de valeurs s√©par√©es par des virgules (pour
    chaque √©l√©ment du vecteur).

-   Un vecteur √† deux √©l√©ments : `c(2, 4)`

-   Un vecteur √† trois √©l√©ments : `c(3, 6, 9)`

Maintenant, regardons encores quelques exemples de vecteurs de
**diff√©rents types** :

```{r}
#| echo: true
# vecteurs num√©riques 
w <- c(-10, 100, 4, -88)

likes_comments_shares <- c(513, 34, 102)

# vecteurs textuels (toujours ajouter des guillemets pour chaque √©l√©ment !)
animaux <- c("chat", "chien", "cheval", "chenille")

Comm_Insta <- c("trop cool", "wsh", "c'est quoi ?")

humains <- c("Claire", "Clarissa", "Theresa", "Marc", "Alma")

# vecteurs logiques :
femme <- c(TRUE, TRUE, TRUE, FALSE, TRUE)

```

::: {.callout-caution collapse="false"}
## Attention

Dans R, on ne peut g√©n√©ralement pas m√©langer les valeurs num√©riques,
textuelles et logiques dans le m√™me vecteur !
:::

## Devoir pour Session 2

-   Si ce n'est pas encore fait : Installez R et RStudio sur votre
    ordinateur.

-   Lisez ensuite encore une fois ce script et ex√©cutez toutes les
    sections de code sur votre ordinateur.

-   Essayez de r√©soudre vous-m√™me les √©ventuels messages d'erreur en
    adaptant le code.

# Session 2

## R√©p√©tition rapide de session 1

```{r}
#| echo: true
#| output: false
#| error: true
# Script de r√©p√©tition

# Avez-vous compris comment R traite les diff√©rents types de variables ?
# Quelle est la diff√©rence entre a et b ?

a <- 5
b <- "5"

# Comment afficher a et b ?


# Alternative : avec la fonction print(), qui augmente la compr√©hension ult√©rieure du code


# Pourquoi le code suivant produit-il une erreur ?
a*b

# Le code suivant corrige √† nouveau l'erreur, pourquoi ?
b <- 5
a*b

# V√©cteurs
v1 <- c(1,2,3,4)
v1

# Vous pouvez cr√©ez des nombres succesifs avec un colon :
v2 <- c(1:10)
v2

v3 <- c("salut", "le", "pote")
v4 <- c(TRUE, FALSE, FALSE)

```

::: {.callout-tip title="Astuce"}
Vous pouvez utiliser la fonction `class()` pour v√©rifier le type d'un
objet, p. ex. (ex√©cutez vous-m√™me !) :

-   `class(c(1,2,3))`

-   `class(c("Hello", "World"))`

-   `class(c(TRUE,TRUE,FALSE))`
:::

## Donn√©es en forme de tableau

Les donn√©es sous forme de tableaux, avec des lignes et des colonnes,
sont au c≈ìur des m√©thodes quantitatives dans les sciences de la
communication.

Dans R, il existe plusieurs structures de donn√©es en format de tableau,
notamment :

-   Les **matrices**

-   Les **data frames**

-   D'autres types, tels que les **tibbles**, qui sont en fait des data
    frames adapt√©s √† des paquets R sp√©cifiques (nous traiterons ce sujet
    plus tard dans le cours).

::: {.callout-important title="Important"}
-   Il est de convention qu'un tableau de donn√©es pr√©sente les **unit√©s
    statistiques** par **ligne** (angl. *row*).
-   Les **variables** ou caract√©ristiques de ces unit√©s statistiques
    sont indiqu√©es en cons√©quence par **colonnes** (angl. *column*).
:::

::: {.callout-note icon="true"}
## √Ä noter

Selon le type de donn√©es, surtout en recherche empirique en sciences
sociales dont font partie les sciences de la communication, les unit√©s
statistiques peuvent √™tre :

-   des **participants** √† un questionnaire ou √† une exp√©rimentation

-   des **documents** (p. ex. articles de presse, posts sur r√©seaux
    sociaux)

-   des **observations/ cas** (p. ex. des profils sur r√©seaux sociaux,
    des entreprises m√©diatiques)

Dans ces jeux de donn√©es, par convention, chaque ligne repr√©sente une
unit√© statistique (ou un participant, un document, une observation),
tandis que chaque colonne repr√©sente les variables qui ont √©t√©
collect√©es pour chaque unit√© statistique.
:::

::: {.callout-note icon="true"}
## √Ä noter

La taille d'un jeu de donn√©es est indiqu√©e par **le nombre d'unit√©s
statistiques n**.

-   Par exemple, si 49 personnes ont r√©pondu √† un questionnaire, nous
    parlons donc d'un √©chantillon de n = 49 participants.
:::

Voici un mod√®le de la mani√®re dont on devrait structurer les r√©ponses √†
un questionnaire avec n participants et X questions :

```{r}
#| echo: false
#| output: true
id <- c("personne_1", "personne_2", "personne_3", "etc.", "personne_n")
question_A <- c("r√©ponse_a_A", "r√©ponse_a_A", "r√©ponse_a_A", "...", "r√©ponse_a_A")
question_B <- c("r√©ponse_a_B", "r√©ponse_a_B", "r√©ponse_a_B", "...", "r√©ponse_a_B")
question_C <- c("r√©ponse_a_C", "r√©ponse_a_C", "r√©ponse_a_C", "...", "r√©ponse_a_C")
etc. <- c("...", "...", "...", "...", "...")
question_X <- c("r√©ponse_a_X", "r√©ponse_a_X", "r√©ponse_a_X", "...", "r√©ponse_a_X")

questionnaire = data.frame(id, question_A, question_B, question_C, etc., question_X)
questionnaire
```

Dans ce mod√®le, l'unit√© statistique de ce jeu de donn√©es est la personne
qui a r√©pondue au questionnaire (un participant). Chaque ligne
correspond donc √† une personne diff√©rente. Les variables, en revanche,
sont les diff√©rentes questions qui ont √©t√© enregistr√©es pour chaque
participant.

Regardons maintenant quelques objets R sous forme de tableau :

## Les matrices

Les **matrices** sont des objets plut√¥t math√©matique. Elles doivent
notamment √™tre compos√© de donn√©es de m√™me type, c'est √† dire num√©rique,
textuel, logique, etc.

On peut cr√©er des objets matriciels avec la commande **`matrix()`**,
avec les arguments suivants :

-   un vecteur de valeurs (p. ex. `c(1,2,3,4,5,6)`)

-   le nombre de lignes (`nrow=`),

-   le nombre de colonnes (`ncol=`) et

-   la *direction* de remplissage des valeurs, c'est-√†-dire par lignes
    (`byrow = TRUE`) ou par colonnes (`byrow = FALSE`).

Cr√©ons quelques matrices exemplaires avec du code R maintenant.

```{r}
#| echo: true
#| output: false
m1 <- matrix(c(1,2,3,4,5,6), nrow = 2, ncol = 3, byrow = FALSE)

print(m1)


m2 <- matrix(c(1:6), nrow = 2, ncol = 3, byrow = TRUE)

print(m2)

# Quelle est la diff√©rence entre m1 et m2 au niveau du code ?

```

::: {.callout-note icon="true"}
## √Ä noter

Si vous ne sp√©cifier pas tous les arguments d'une fonction, R va tenter
d'utiliser des arguments par d√©fauts.
:::

```{r}
# On peut p. ex. cr√©er une matrice sans sp√©cifier tout les arguments de la fonction matrix()
m3 <- matrix(c(1:10), nrow = 5)

print(m3)
```

Vous pouvez extraire des √©l√©ments individuels ou des parties d'une
matrice avec des **parenth√®ses carr√©es `[]`** en sp√©cifiant les lignes
et les colonnes concern√©es.

```{r}
#| echo: true
#| output: true
# Cr√©ons d'abord un matrice m4 avec 100 √©l√©ments :
m4 <-  matrix(c(1:100), nrow = 10, byrow = TRUE)
print(m4)

# Extraire le deuxi√®me √©l√©ment de la troisi√®me ligne :
m4[3,2]

# Extraire les cinq premiers √©l√©ments de la dixi√®me ligne :
m4[10, c(1:5)]

# Extraire tous les √©l√©ments de la premi√®re ligne :
m4[1,]

# Extraire tous les √©l√©ments de la troisi√®me colonne :
m4[,3]

# Extraire la moiti√© sup√©rieure de la matrice :
m4[c(6:10),]

```

## Les data frames

::: {.callout-note icon="true"}
## √Ä noter

Les **data frames** (fran√ßais : *cadre de donn√©es*) sont le type de
donn√©e en forme tableau le plus commun dans R. Cette structure de donn√©e
peut notamment √™tre compos√© de donn√©es de diff√©rents types (num√©rique,
textuel, logique).
:::

Cr√©ons un data frame avec la fonction `data.frame()` maintenant. Nous
appelons ce type d'objets d√©sormais un **jeu de donn√©es**.

![Le film √Çge de glace [Source :
wikimedia.org](https://en.wikipedia.org/wiki/File:Ice_Age_Dawn_of_the_Dinosaurs_theatrical_poster.jpg)](https://upload.wikimedia.org/wikipedia/en/2/24/Ice_Age_Dawn_of_the_Dinosaurs_theatrical_poster.jpg)

```{r}
#| echo: true
#| output: false

# Cr√©ons d'abord un vecteur textuel avec les noms de certains animaux du film L'√¢ge de glace.
name <- c("Manny", "Sid", "Diego", "Ellie", 
          "Peaches", "Scrat", "Rudy", "Buck")

#Un second vecteur textuel indique l'esp√®ce de chaque animal.
species <- c("mammoth", "sloth", "sabertooth", "mammoth", 
             "mammoth", "squirrel", "dinosaur", "weasel")

# Un troisi√®me vecteur logique indique si chaque animal est une femelle
female <- c(FALSE, FALSE, FALSE, TRUE, 
            TRUE, FALSE, FALSE, FALSE)

# Un quatri√®me vecteur num√©rique indique l'√¢ge en ann√©es de chaque animal.
age <- c(30, 20, 35, 25, 
         7, 4, 100, 28)

# Un cinqui√®me tableau num√©rique indique le poids en kg de chaque animal.
weight <- c(5000, 80, 400, 4000, 
            1000, 1, 10000, 3)

# La fonction data.frame() permet d'utiliser les vecteurs pour former un tableau de donn√©es.
ice_age_df <- data.frame(name, species, female, age, weight)

```

Nous pouvons afficher l'objet `ice_age_df` en ex√©cutant son nom ou en
utilisant la fonction `print()` :

```{r}
print(ice_age_df)
```

### Quelques fonctions utiles pour analyser les data frames

Il existe plusieurs **fonctions utiles** dans R qui vous permettent
d'analyser les propri√©t√©s de jex de donn√©es de type data frame (et
d'autres types d'objets R), comme p. ex. :

-   `dim()` : Retourne les dimensions d'un jeu de donn√©es - le nombre de
    lignes et de colonnes.

-   `head()` : Affiche les six premi√®res lignes du jeu de donn√©es.

-   `str()` : Fournit la structure du jeu de donn√©es, y compris

    -   le type de variable de chaque colonne,

    -   le nombre d'observations et

    -   les premi√®res entr√©es de chaque colonne.

        C'est un moyen rapide de se faire une id√©e du contenu de votre
        jeu de donn√©es.

-   `summary()`: Donne un r√©sum√© du jeu de donn√©es, y compris des
    statistiques telles que

    -   la moyenne,

    -   la m√©diane,

    -   le minimum et le maximum pour les variables num√©riques, et

    -   les fr√©quences pour les variables factorielles.

        Cette fonction est utile pour obtenir rapidement une vue
        d'ensemble des statistiques.

```{r}
#| echo: true
#| output: true

# Utilisons ces fonctions pour analyser l'objet ice_age_df

dim(ice_age_df)
head(ice_age_df)
str(ice_age_df)
summary(ice_age_df)

```

::: {.callout-tip title="Astuce"}
Une autre astuce utile consiste √† utiliser le **`$`** pour **extraire
des colonnes sp√©cifiques** d'un jeu de donn√©es.
:::

```{r}
#| echo: true
#| output: true
# P. ex. :
ice_age_df$name

# Essayez vous-m√™me et extrayez d'autres colonnes de ice_age_df √† l'aide du $ !
```

## Fonctions statistiques de base

Il existe dans R toute une palette de fonctions statistiques qui vous
permettent d'√©valuer principalement des donn√©es de type num√©rique.
Quelques fonctions utiles pour les statistiques descriptives de base :

-   `mean()` : Calcule la moyenne arithm√©tique

-   `median()` : Calcule la m√©diane

-   `sd()` : Calcule l'√©cart-type (angl. *standard deviation*)

-   `var()` : Calcule la variance

```{r}
#| echo: true
#| output: false
a1 <- c(1,2,100)

mean(a1)

median(a1)

sd(a1)

var(a1)
```

```{r}
#| echo: false
#| output: true
a1 <- c(1,2,100)

mean(a1)

median(a1)

sd(a1)

var(a1)
```

## Les facteurs

Un autre type de variable cl√© dans R est ce que l'on appelle les
**facteurs**, qui sont essentiellement des **variables cat√©gorielles**.

::: {.callout-note icon="true"}
## √Ä noter

Les facteurs sont des variables qui prennent un nombre limit√© de valeurs
diff√©rentes (appel√©es *levels* dans R).

Il existe deux sous-type de facteurs :

-   Les **facteurs nominaux** (sans ordre) : toutes les cat√©gories sont
    √©quivalentes les unes aux autres. Il n'y a pas de hi√©rarchisation.

    -   Exemples : le genre et l'appartenance √† un parti

-   Les **facteurs ordinaux** (avec un ordre): il y a un ordre ou une
    hi√©rarchie sp√©cifi√© parmi les cat√©gories (p. ex. des niveaux tels
    que *faible*, *moyen*, *√©lev√©*).

    -   Exemples : niveau d'√©ducation, cohortes d'√¢ge
:::

Vous pouvez cr√©er un facteur nominal √† l'aide de la fonction `factor()`
et v√©rifier ses cat√©gories avec `levels()`. Voici un exemple :

```{r}
#| echo: true
#| output: true
# Cr√©er un vecteur de donn√©es cat√©gorielles, d'abord de type textuel
genre <- c("homme", "femme", "femme", "femme", "homme")

# Le convertir ensuite en facteur
facteur_genre <- factor(genre)

# Voir les niveaux du facteur genre
levels(facteur_genre)

# Imprimer le facteur (montre aussi les niveaux)
print(facteur_genre)
```

Et voici comment cr√©er un facteur ordinal :

```{r}
#| echo: true
#| output: true
# Voici un vecteur textuel avec des tailles de T-shirt
tailles <- c("Small", "Medium", "Large", "Medium", "Small")

# On le transforme en facteur ordinal en sp√©cifiant les arguments suivants :
tailles_facteur <- factor(tailles, order = TRUE, levels = c("Small", "Medium", "Large"))

levels(tailles_facteur)

print(tailles_facteur)

```

Transformons maintenant la colonne `species` de notre jeu de donn√©es
`ice_age_df` en facteur avec la fonction `as.factor()`:

```{r}
#| echo: true
#| output: true
# V√©rifions d'abord la structure de l'objet ice_age_df :
str(ice_age_df)

# Transformation en facteur :
# ice_age_df$species <- as.factor(ice_age_df$species)

# V√©rifions encore une fois la structure de l'objet :
# str(ice_age_df)

```

C'est maintenant √† vous de transformer la colonne `name` de
`ice_age_df`en facteur !

## Le r√©p√©rtoire de travail

::: {.callout-important title="Important"}
Dans R, le **r√©pertoire de travail** (angl. *working directory*) fait
r√©f√©rence au dossier de votre ordinateur dans lequel R lit et enregistre
les fichiers par d√©faut. Il s'agit d'un concept crucial dans la
programmation R, car il d√©termine l'endroit o√π R recherche les fichiers
√† lire et l'endroit o√π il place les fichiers lorsque vous les
enregistrez.
:::

Vous pouvez d√©finir votre r√©pertoire de travail avec la fonction
**`setwd()`**.

Une possibilit√©, c'est de le faire manuellement dans le volet *output*
en bas √† droite :

1.  Naviguez sur l'onglet **Files**
2.  Cliquez sur les trois petits points **...** tout √† droite
3.  Choisissez un dossier sur votre ordinateur qui peut servir de
    r√©pertoire de travail (vous devez peut-√™tre en cr√©er un d'abord et
    lui donner un nom utile, p.ex. "ex_meth_sp24"
4.  Cliquez ensuite sur la petite **roue bleue** (More) et choisissez
    **Set as Working Directory**
5.  Vous pouvez ensuite copier et coller le code R qui d√©finit le
    r√©pertoire de travail depuis l'onglet de la console et l'inclure
    dans votre script R

Sur l'ordinateur de l'enseignant, ce code est le suivant :
`setwd("C:/Users/julim/switchdrive/001_Exercices_Methodes_2_SP_22/R")`
**Attention** : Ce code ne marche naturellement pas sur votre machine.
Il faut l'adapter et inclure un chemin de fichier de votre ordinateur.

Vous pouvez ensuite v√©rifier si le r√©pertoire de travail a √©t√©
correctement d√©fini avec la fonction `getwd()`

## Devoir pour Session 3 (Problem Set 1)

-   **Problem Set 1**

    -   Le Problem Set 1 est un QCM sur Moodle qui sera accessible
        pendant les 30 premi√®res minutes de l'exercice.

    -   Assurez-vous que R et RStudio fonctionnent sur votre ordinateur
        portable et qu'il a suffisamment de batterie. Il est de votre
        responsabilit√© de vous en assurer.

    -   Dans le Problem Set 1, il y a √† la fois des questions que vous
        devez r√©soudre avec du code R et des questions de compr√©hension
        qui peuvent √™tre r√©solues sans code. Vous devez donc √™tre
        capable non seulement d'ex√©cuter le code, mais aussi d'en
        comprendre l'objectif.

    -   R√©p√©tez le contenu des sessions 1 et 2 sur votre ordinateur afin
        de bien vous pr√©parer pour le Problem Set 1.

    -   Assurez-vous que toutes les parties du code fonctionnent sans
        message d'erreur.

-   **Attention** :

    -   Vous devez tous venir la semaine prochaine dans le groupe dans
        lequel vous √™tes inscrits via my.unifr (A, B, C, D) si vous
        voulez participer au Problem Set 1.

    -   Chaque √©tudiant.e n'aura acc√®s qu'au Problem Set 1 de son
        groupe.

    -   Les personnes qui ne sont inscrites dans aucun groupe ne peuvent
        pas valider le Problem Set 1.

# Session 3 (Problem Set 1)

Les r√©sultats du **Problem Set 1** (bonnes r√©ponses, √©chelle des notes)
sont acc√©ssibles sur la page Moodle de l'exercices.

Voici l'histogramme des points obtenus par n = 81 √©tudiant.es qui ont
particip√© au Problem Set 1. Le nombre maximal de points √©tait de 20, il
fallait 10 pour passer le test.

```{r}
#| echo: false
#| output: true
#| warning: false
# script pour faire un histogramme des points obtenus dans le Problem Set 1
# cours : Exercices M√©thodes II
# date : 6/7 mars 2024
# auteur : Julian Maitra

library(ggplot2)

# Adaptez le code suivant pour votre r√©pertoire de travail :

setwd("/Users/domus_julian/Documents/GitHub/intro-a-R/code")

# Enregistrez le fichier CSV points_ps_2 dans votre r√©pertoire de travail, 
# puis importez les donn√©es dans R (modifiez le code suivant selon votre ordinateur) :

points_ps_1 <- read.csv("~/Documents/GitHub/intro-a-R/code/points_PS_1.csv", encoding="UTF-8")

#points_ps_1 # il y a 81 observations de trois variables : etudiant.e, groupe et points

hist_ps_1 <-ggplot(points_ps_1, 
                   aes(x=points)) + 
  geom_histogram(binwidth = 1, color="black", fill="white") +
  labs(title = "Histogramme des points obtenus dans le PS 1", # labs() permet de d√©finir plusieurs labels en m√™me temps (titre, axes, etc.)
       subtitle = "n = 81 r√©sultats de test", 
       caption = "Source des donn√©es : Moodle") +       
  xlab("Points obtenus") +                             
  ylab("Fr√©quence") + 
  scale_x_continuous(breaks=seq(1, 20, 1)) + # cette couche d√©finit les unit√© de l'axe x
  scale_y_continuous(breaks=seq(0, 20, 2)) + # cette couche d√©finit les unit√© de l'axe x
  theme_minimal() 
hist_ps_1
```

# Session 4

La session 4 a pour but d'introduire trois √©l√©ments fondamentaux en
analyse de donn√©es avec R :

1.  Installer et charger des **paquets R** sur son ordinateur
2.  Utiliser des **jeux de donn√©es int√©gr√©s en R** pour s'entra√Æner en
    analyse de donn√©es
3.  Apprendre √† utiliser le paquet **ggplot2** pour cr√©er des
    visualisations de donn√©es

## Les paquets R

::: {.callout-note icon="true"}
## √Ä noter

Dans la programmation R, un **paquet** (angl. *package*) est un ensemble
de fonctions, de donn√©es et de code compil√© dans un format bien d√©fini.

Les paquets √©tendent les fonctionnalit√©s de R de base en fournissant des
outils suppl√©mentaires pour l'analyse des donn√©es, la visualisation,
l'apprentissage automatique, la mod√©lisation statistique et beaucoup
d'autres applications sp√©cialis√©es.

Les paquets R peuvent √™tre d√©velopp√©s par n'importe qui et partag√©s
gratuitement avec d'autres (open source). Par cons√©quent, une grande
multitude de paquets R sont disponibles.
:::

Notez que la plupart des paquets R doit √™tre install√© s√©par√©ment,
normalement depuis le site [Comprehensive R Archive Network
(CRAN)](http://cran.r-project.org). Dans ce cours, nous nous
concentrerons sur deux paquets c√©l√®bres :

-   `ggplot2` pour cr√©er des **visualisations de donn√©es**

-   `dplyr` pour **manipuler les jeux de donn√©es**

Tous deux font partie du [tidyverse](https://www.tidyverse.org), une
collection de paquets con√ßus pour la science des donn√©es. Nous
utiliserons √©galement le paquet suivant :

-   `ggthemes` pour **augmenter le design des graphiques**

Pour utiliser un paquet R sur votre ordinateur, il faut :

1.  D'abord **installer** le paquet en question avec la fonction
    `install.packages()`. Cela peut durer quelques minutes.
2.  Ensuite **activer** le paquet avec la fonction `library()`.

::: {.callout-tip title="Astuce"}
Dans RStudio, on peut aussi installer les paquets via l'onglet **Tools**
et le menu d√©roulant : Cliquez sur *Install Packages*... et cherchez les
paquets que vous voulez installer.
:::

Utilisez le code suivant pour installer les paquets R requis pour notre
cours. Enlevez les croisillons, √©x√©cutez le code avec
`install.packages()` puis r√©ajouter les croisillons pour √©viter de
r√©installer les paquets chaque fois que vous √©x√©cutez le code dans votre
script ! Activer ensuite les paquets avec `library()`.

```{r}
#| echo: true
#| output: false
# install.packages("tidyverse")
# install.packages("ggthemes")

library(tidyverse)
library(ggthemes)
```

√Ä noter : `ggplot2` et `dplyr` sont install√©s avec le `tidyverse`, il ne
faut donc plus les installer s√©par√©ment.

::: {.callout-caution collapse="false"}
## Attention

Notez qu'une fois install√©, vous n'avez pas besoin de le r√©installer les
paquets √† chaque fois avec `install.packages()`. Cependant, vous devez
**activer** tous les paquets R que vous voulez utiliser dans une session
avec la commande `library()`. Sans activation, vous allez recevoir des
messages d'erreur.
:::

Certains paquets ont des documentations auxquelles vous pouvez acc√©der
gr√¢ce au point d'interrogation. Ces infos sont affich√©s dans le volet
*Output* sous l'onglet *Help*.

-   `?ggplot2`

-   `?dplyr`

En ligne, vous pouvez √©galement trouver de nombreuses ressources qui
expliquent en d√©tail les fonctionnalit√©s des diff√©rents paquets R et
vous renvoient vers d'autres livres, tutoriels, cours, etc., p. ex. :

-   [Documentation officielle de
    `ggplot2`](https://ggplot2.tidyverse.org/index.html)

-   [Documentation officielle de `dplyr`](https://dplyr.tidyverse.org)

-   [Exemples de graphiques cr√©es avec les diff√©rents designs de
    `ggthemes`](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/)

Vous pouvez v√©rifier quels paquets sont **actuellement install√©s sur
votre ordinateur** avec la fonction `installed.packages()` (vous pouvez
laisser vide l'espace entre parenth√®ses) :

```{r}
#| echo: true
#| output: false
installed.packages()
```

## Les jeux de donn√©es int√©gr√©s

Une excellente fa√ßon, et probablement la plus efficace, d'apprendre √†
utiliser R pour l'analyse de donn√©es consiste √† travailler avec des
**jeux de donn√©es int√©gr√©s dans R**.

Ces jeux de donn√©es exemplaires pr√©sentent deux avantages principaux.

1.  Il est facile d'y acc√©der et de les charger dans votre session
    RStudio, car ils sont int√©gr√©s √† R et √† certains de ses paquets.

Cela les distingue fortement des donn√©es du "monde r√©el", comme les
donn√©es de questionnaires ou de m√©dias sociaux, qu'il faut souvent
d'abord nettoyer et formater, puis importer dans RStudio sous forme de
fichiers externes. Avec les jeux de donn√©es int√©gr√©s, vous pouvez
imm√©diatement commencer l'analyse et la visualisation des donn√©es.

2.  Ces jeux de donn√©es ont prouv√© leur utilit√© dans d'innombrables
    supports d'apprentissage.

Par cons√©quent, vous pouvez facilement trouver des ressources
suppl√©mentaires et des exemples de code √† leur sujet.

Dans ce qui suit, nous allons explorer quatre jeux de donn√©es classiques
de ce type :

-   `iris`

-   `mtcars`

-   `diamonds`

-   `palmerpenguins`

::: {.callout-tip title="Astuce"}
Vous pouvez afficher les jeux de donn√©es qui sont actuellement
acc√©ssible sur votre ordinateur avec la commande `data().`
:::

### le jeu de donn√©es `iris`

Le jeu de donn√©es `iris` est un ensemble de donn√©es c√©l√®bre qui contient
les mesures en centim√®tres des variables longueur et largeur du s√©pale,
ainsi que longueur et largeur du p√©tale, pour trois exp√®ces de fleurs
d'iris (Setosa, Virginica et Versicolor). Il y a 150 observations en
total (50 pour chaque esp√®ce).

Le jeu de donn√©es a √©t√© rendu c√©l√®bre par le statisticien et biologiste
britannique **Ronald Fisher** dans un article scientifique de 1936 qui
avait beaucoup d'influence dans le domaine des statistiques. Les donn√©es
d'iris eux-m√™me ont √©t√© r√©colt√© par le botaniste Edgar Anderson en 1935
sur la p√©ninsule de Gasp√©sie au Qu√©b√©c, Canada.

::: {.callout-caution collapse="true"}
## Plus sur Ronald Fisher

Ronald Fisher (1890-1962) √©tait un statisticien, g√©n√©ticien et
biologiste britannique qui a jou√© un r√¥le crucial dans le d√©veloppement
de la science statistique moderne. Il est connu pour son travail dans le
d√©veloppement des fondements des m√©thodes statistiques, incluant
l'analyse de variance (ANOVA), le test exact de Fisher et l'estimation
du maximum likelihood. Fisher a √©galement apport√© des contributions
significatives en g√©n√©tique, o√π son travail sur la th√©orie de la
s√©lection naturelle et la g√©n√©tique des populations a aid√© √† combler le
foss√© entre la g√©n√©tique mend√©lienne et l'√©volution darwinienne. Il est
consid√©r√© comme l'un des architectes principaux de la synth√®se
n√©o-darwinienne. Son influence s'√©tend au-del√† de la statistique et de
la g√©n√©tique aux domaines plus larges de la biologie et de la recherche
agricole, faisant de lui une figure pivotale de la science du 20e
si√®cle.
:::

<a title="Diego Mariano, CC BY-SA 4.0 &lt;https://creativecommons.org/licenses/by-sa/4.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Flores_de_%C3%8Dris.png"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/Flores_de_%C3%8Dris.png/512px-Flores_de_%C3%8Dris.png" alt="Flores de √çris" width="512"/></a>

Il y a des statistiques sur trois esp√®ces d'iris dans le jeu de donn√©es
[Source :
wikimedia.org](https://commons.wikimedia.org/wiki/File:Flores_de_√çris.png)

Dans l'apprentissage de R, ce jeu de donn√©es est souvent utilis√© pour
illustrer diverses techniques d'analyse de donn√©es, y compris le
clustering, la classification et la visualisation.

Explorons un peu le jeu de donn√©es `iris` avec du code !

```{r}
#| echo: true
#| output: false

dim(iris) # Ceci affiche le nombre de lignes et de colonnes)

head(iris) # Affiche les six premi√®res lignes

str(iris) # Informations sur la structure du jeu de donn√©es

names(iris) # Affiche les noms des colonnes
```

Regardons ce que √ßa donne apr√®s l'√©x√©cution de chaque ligne de code :

```{r}
#| echo: true
#| output: true

dim(iris) 

head(iris) 

str(iris) 

names(iris) 
```

::: {.callout-tip title="Astuce"}
Vous pouvez consulter la documentation pour beaucoup de jeux de donn√©es
avec un point d'interrogation : `?iris()`.
:::

### le jeu de donn√©es `mtcars`

Utilisez le script suivant pour analyser `mtcars`(lisez √©galement la
documentation avec `?mtcars`) !

```{r}
#| warning: false
#| echo: true
#| output: false

# Chargez le jeu de donn√©es mtcars. Il devrait appara√Ætre dans l'environnement
data(mtcars)

# Affichez mtcars
mtcars

# vous pouvez explorer mtcars manuellement en double cliquant dessus dans l'environnement

# Affichez seulement les six premi√®res observations
head(mtcars)

# Affichez seulement les six derni√®res observations
tail(mtcars)

# Appliquez quelques autres commandes pour explorer ce jeu de donn√©es
class(mtcars)
dim(mtcars)

str(mtcars)
summary(mtcars)

glimpse(mtcars) # cette commande marche seulement si vous avez activ√© le tidyverse

# Extraire la colonne mpg ("miles per gallon") avec le signe $
# et calculer la moyenne, la m√©dianne, le minimum et le maximum

mtcars$mpg

mean(mtcars$mpg)

median(mtcars$mpg)

min(mtcars$mpg)

max(mtcars$mpg)
```

<a title="Jeremy from Sydney, Australia, CC BY 2.0 &lt;https://creativecommons.org/licenses/by/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:1974_Toyota_Corolla_(KE20)_L_2-door_sedan_(20538771443).jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/1974_Toyota_Corolla_%28KE20%29_L_2-door_sedan_%2820538771443%29.jpg/512px-1974_Toyota_Corolla_%28KE20%29_L_2-door_sedan_%2820538771443%29.jpg" alt="1974 Toyota Corolla (KE20) L 2-door sedan (20538771443)" width="512"/></a>

Un des mod√®les de mtcars : Le Toyota Corolla de 1974. [Source :
wikimedia.org](https://commons.wikimedia.org/wiki/File:1974_Toyota_Corolla_(KE20)_L_2-door_sedan_(20538771443).jpg)

### le jeu de donn√©es `diamonds`

C'est maintenant √† vous d'explorer ce jeu de donn√©es avec du code !

Utilisez √©galement `?diamonds()` !

<a title="Jerry Cone, Public domain, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Diamond-1128734.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1d/Diamond-1128734.jpg/512px-Diamond-1128734.jpg" alt="Diamond-1128734" width="512"/></a>

Qu'est-ce qui d√©finit le prix d'un diamant ? [Source :
wikimedia.org](https://commons.wikimedia.org/wiki/File:Diamond-1128734.jpg)

## Introduction aux visualisations avec `ggplot2`

::: {.callout-note icon="true"}
## √Ä noter

`ggplot2`, qui fait partie du `tidyverse`, est un paquet de
visualisation de donn√©es tr√®s populaire dans R. Il a √©t√© con√ßu pour
faciliter la cr√©ation de graphiques complexes et multicouches avec une
syntaxe coh√©rente et consistante nomm√©e *grammar of graphics*.

*ggplot2* est donc un acronyme form√© √† partir des mots *grammar of
graphics plots* (fran√ßais : *grammaire des graphiques*). Le "2" dans
ggplot2 indique simplement la deuxi√®me g√©n√©ration de ce paquet R.

Avec `ggplot2`, les utilisateurs peuvent construire des graphiques de
mani√®re incr√©mentale en ajoutant des couches, ce qui le rend flexible
pour une large gamme de besoins graphiques. Cela permet de cr√©er des
visualisations hautement personnalisables et esth√©tiquement attrayantes,
allant de simples diagrammes de dispersion √† des figures multi-panneaux
complexes.
:::

Le tableau suivant d√©crit les couches d'un graphique ggplot :

| Couche                                                             | D√©scription/Variables                                                                         | Obligatoire ? |
|-----------------------|:--------------------|:--------------------------:|
| *data*                                                             | le jeu de donn√©es que nous voulons visualiser                                                 |      oui      |
| *aesthetics*                                                       | le *mapping* de nos variables : axes *x* et *y*, *color*, *fill*, *alpha*, *line width*, etc. |      oui      |
| *geometries*                                                       | le type visuel du graphique : *point*, *line*, *histogram*, *bar*, *boxplot*                  |      oui      |
| *themes*                                                           | Le design du graphique                                                                        |      non      |
| Autres couches optionelles : *facets*, *statistics*, *coordinates* | Pour des visualisations plus complexes                                                        |      non      |

: Les couches d'un graphique ggplot

Pour comprendre comment cela fonctionne, voici un exemple de code dans
lequel les diff√©rentes couches d'un graphique *ggplot* sont ajout√©es
√©tape par √©tape dans la fonction `ggplot()`. (Normalement, nous ne
proc√©derions pas ainsi, mais utiliserions directement le code en entier
pour cr√©er le graphique).

Le but dans cet exemple est de visualiser le jeu de donn√©es `diamonds`
pour comprendre la relation entre les variables `price` (prix) et
`carat` (poids) des diamants dans le jeu de donn√©es !

::: {.callout-note icon="true"}
## √Ä noter

Important : avant d'analyser un ensemble de donn√©es, il faut toujours
acqu√©rir des **connaissances contextuelles** sur ce que les donn√©es
repr√©sentent.

Dans notre exemple, il s'agit de diamants. Dans le monde des diamants,
il est important de comprendre qu'il existe **quatre crit√®res de
qualit√©** qui d√©terminent **la valeur** (donc le prix) d'un diamant. Ce
sont les suivants :

-   La taille (angl. *cut*)

-   La puret√© (*clarity*)

-   La couleur (*color*)

-   Le poids en carats (*carat*)

En anglais, on parle donc aussi des 4C. Le jeu de donn√©es `diamonds`
contient pr√©cis√©ment ces variables.
:::

```{r}
# La premi√®re couche, data, d√©finit le jeu de donn√©es
ggplot(data = diamonds)
```

Notre graphique n'est pour l'instant qu'une zone grise ! Catastrophe ?
Bien s√ªr que non üòÄ. Nous devons maintenant d√©finir les autres
param√®tres de la fonction `ggplot()` !

```{r}
# La deuxi√®me couche, aesthetics, d√©finit le mapping de nos variables sur les axes y et x
ggplot(data = diamonds,
       mapping = aes(x = carat, y = price))
```

La zone grise a maintenant re√ßu des unit√©s pour ses axes x (`carat`) et
y (`price`). Mais il n'y a toujours pas de donn√©es affich√©es !

```{r}
# La troisi√®me couche, geometries, d√©finit le type visuel de notre graphique
ggplot(data = diamonds,
       mapping = aes(x = carat, y = price)) +
  geom_point()
```

Ouf, si vous avez ex√©cut√© le dernier code, vous avez maintenant 53 940
points de donn√©es affich√©es dans votre graphique ! Car il y a tant
d'observations dans le jeu de donn√©es `diamonds`.

Bon courage si vous avez un vieil ordinateur, cela peut prendre un
certain temps avant que R ne produise le graphique...

Mais jetons un coup d'≈ìil au graphique. Qu'est-ce qui saute aux yeux,
pouvez-vous d√©j√† identifier des tendances ?

```{r}
# On peut maintenant encore optimiser notre graphique
ggplot(data = diamonds,
       mapping = aes(x = carat, y = price, color = clarity)) +
  geom_point()
```

Vous avez remarqu√© ce qui a chang√© dans le code ?

```{r}
# Ajoutons encore une couche optionnelle mais utile au graphique : labs() nous permet d'ajouter et de personnaliser des titres, sout-titres, titre d'axes, titres de l√©gendes, etc. ! 
ggplot(data = diamonds,
       mapping = aes(x = carat, y = price, color = clarity)) +
  geom_point() + 
  labs(title = "La relation entre prix et carat des diamants",
    subtitle = "n = 53 940 diamants",
    y = "Prix", 
    x = "Carat", 
    colour = "Puret√©")
```

Maintenant il s'agit d'interpr√©ter le graphique. Que nous dit-il sur la
relation entre prix et carats des diamants ? Quel r√¥le joue la variable
*puret√©* (`clarity`)?

## Devoir pour Session 5

-   Ex√©cutez toutes les sections de code de la session 4 sur votre
    ordinateur.

-   Entra√Ænez-vous √† ouvrir un nouveau script R, √† d√©finir un r√©pertoire
    de travail et √† enregistrer le script dans un dossier sur votre
    ordinateur.

-   Assurez-vous que le paquet R `tidyverse` est install√© correctement
    sur votre ordinateur.

-   Utilisez le code R de mani√®re autonome pour explorer le jeu de
    donn√©es `diamonds`. Vous devez √™tre en mesure de comprendre et
    d'expliquer comment il est structur√© (nombre d'observations n, unit√©
    statistique, variables, origine des donn√©es, etc).

# Session 5

La session 5 a pour but d'approfondir les techniques de visualisation de
donn√©es avec le paquet `ggplot2`, notamment la cr√©ation des types de
graphique suivants :

1.  Les nuages de points (angl. *scatter plots*)
2.  Les diagrammes √† barres (angl. *bar plots*)
3.  Les histogrammes (angl. *histograms*)
4.  Les bo√Ætes √† moustaches (angl. *box plots*)

```{r}
#| warning: false
# N'oubliez pas de charger les paquets tidyverse et ggthemes !
# Ex√©cutez le code suivant pour le faire :
library(tidyverse)
library(ggthemes)
```


## 1. Les nuages de points (angl. *scatter plots*)

Commen√ßons par le **nuage de points**, que nous avons d√©j√† vu lors de la
derni√®re session, lorsque nous avons visualis√© la relation entre les
carats et les prix dans le jeu de donn√©es `diamonds`.

::: {.callout-note icon="true"}
## √Ä noter

Un **nuage de points** (aussi appel√© diagramme de dispersion) est
utilis√© dans `ggplot2` pour repr√©senter les valeurs de **deux variables
num√©riques diff√©rentes** par des points, avec une variable sur l'axe des
X et l'autre sur l'axe des Y.

Ce type de graphique est id√©al pour l'analyse exploratoire de donn√©es,
permettant d'observer les relations entre les variables, de d√©tecter des
tendances, des regroupements, des valeurs √™xtremes (angl. *outliers*) ou
de v√©rifier des hypoth√®ses de corr√©lation.

Dans la fonction `ggplot()`, un scatter plot est cr√©√© avec la couche
g√©om√©trique `geom_point()`.
:::

Cr√©ons un nuage de points avec le jeu de donn√©es `iris`, en comparant
les longueurs et les largeurs des s√©pales des iris (les variables
`Sepal.Length` et `Sepal.Width`).

Notez que, dans le code suivant, nous ne cr√©ons pas directement un
graphique `ggplot` mais nous stockons le graphique comme un objet dans
l'environnement, nomm√© `p1`, que nous pouvons ensuite afficher avec la
fonction `print()`. Nous verrons dans un instant pourquoi cette pratique
est utile.

```{r}
# nuage de points basique pour comparer la longueur et la largeur des s√©pales des iris
np1 <- ggplot(data = iris, 
               mapping = aes(x=Sepal.Length, y=Sepal.Width)) +
  geom_point() +
  labs(title = "Sepal length and width in the iris dataset")

print(np1)
```

Nous pouvons ajouter des couches √† l'objet `np1` sans l'√©craser, p. ex.
une ligne de r√©gression lin√©aire avec `geom_smooth(method = lm)` :

```{r}
#| warning: false
np1 + geom_smooth(method = lm)
```

Que nous indique la ligne de r√©gression ? En principe, elle indique une
correlation l√©g√®rement n√©gative entre les variables `Sepal.Length`et
`Sepal.Width` ! (la zone grise autour de la ligne bleue indique une marge
d'erreur).

Cela signifie que les iris dont les s√©pales sont plus longs ont tendance
√† avoir des s√©pales un peu moins larges ! Gardez cette constatation √†
l'esprit pour les √©tapes de codage suivantes.

```{r}
# Ecrasons np1 en changeant un peu le code. D√©couvrez vous-m√™me ce qui a chang√© dans le code !
np1 <- ggplot(iris, 
               aes(x=Sepal.Length, y=Sepal.Width, color = Species)) +
  geom_point() +
  labs(title = "Sepal length and width in the iris dataset")

print(np1)
```

Vous pouvez voir dans le graphique que nous pouvons maintenant
diff√©rencier les trois esp√®ces d'iris. La dispersion des points semble
moins al√©atoire, ce qui permet de voir des groupes de points appartenant
√† l'une ou l'autre esp√®ce (angl. *cluster*).

Maintenant, ajoutons √† nouveau une couche `geom_smooth()` √† l'objet
`np1` !

```{r}
#| warning: false
np1 + geom_smooth(method = lm)
```

Les trois lignes de r√©gression (une pour chaque type d'iris) montrent
maintenant un tout autre r√©sultat : en effet, la corr√©lation entre
`Sepal.Length` et `Sepal.Width` est clairement positive.

Cette constatation est un exemple d'analyse exploratoire des donn√©es,
rendue possible par les possibilit√©s de visualisation de `ggplot2`.

## 2. Les diagrammes √† barres

::: {.callout-note icon="true"}
## √Ä noter

Les **diagrammes √† barres** dans R avec `ggplot2` sont utilis√©s pour
repr√©senter visuellement des **donn√©es cat√©gorielles**, permettant de
comparer des quantit√©s entre diff√©rentes cat√©gories.

On les utilise donc souvent pour montrer la fr√©quence ou la proportion
d'observations dans chaque cat√©gorie, ce qui les rend utiles pour
analyser des tendances ou des diff√©rences au sein de donn√©es
cat√©gorielles.

Dans la fonction `ggplot()`, un diagramme √† barres est cr√©√© avec la
couche g√©om√©trique `geom_bar()`.
:::

Par exemple, nous pouvons utiliser le code simple suivant pour comparer
la fr√©quence des diff√©rentes tailles (angl. `cut`) dans le jeu de
donn√©es `diamonds`. Cette-fois ci, nous sauvegardons et nommons le
graphique `db1`.

```{r}
db1 <- ggplot(data = diamonds, 
       mapping = aes(x = cut)) + 
        geom_bar()

print(db1)
```

Am√©liorons le graphique avec des param√®tres et des couches
suppl√©mentaires de la fonction `ggplot()` (Notez que nous allons
simplement √©craser l'objet `db1` cr√©√© pr√©c√©demment avec une nouvelle
version de `db1` !) :

```{r}
library(ggthemes)

db1 <- ggplot(data = diamonds, 
       mapping = aes(x = cut, fill = cut)) + 
        geom_bar() +
        labs(title = "Frequency of cut quality types in the diamonds dataset",
             subtitle = "n = 53,940 diamonds",
             x = "Cut Quality", y = "Count") +
        theme_minimal()

print(db1)
```
Que nous dit le graphique ? Il est int√©ressant de constater que dans le jeu de donn√©es `diamonds`, le niveau de qualit√© le plus √©lev√© de la taille, √† savoir `ideal`, est √©galement le plus fr√©quent.

::: {.callout-caution collapse="false"}
## Attention

Dans la fonction `ggplot()`, il y a une diff√©rence si vous
voulez ajouter de la couleur aux points (qui ont math√©matiquement z√©ro
dimension) ou aux surfaces (qui ont deux dimensions), comme dans les
diagrammes √† barres.

Si vous voulez ajouter de la couleur √† une surface, vous devez utiliser
l'argument `fill = "xyz"`. L'argument `color = "xyz"` que nous avons
utilis√© pour ajouter de la couleur aux nuages de points ne fera
qu'ajouter de la couleur √† la ligne autour de la surface !
:::

### C'est maintenant √† vous de jouer ! 
Reprenez le code que nous avons utilis√© pour cr√©er `db1` et modifiez-le pour cr√©er un nouvel objet,`db2`, qui visualise la fr√©quence des types de qualit√© de couleur (`color`) dans le jeu de donn√©es `diamonds` sous la forme d'un diagramme √† barres !

## 3. Les histogrammes

::: {.callout-note icon="true"}
## √Ä noter

Un **histogramme** est un type de graphique utilis√© pour repr√©senter
**la distribution** d'**une variable num√©rique** √† travers des barres.

Un "histogramme s√©pare les valeurs possibles des donn√©es en classes ou
groupes. Pour chaque groupe, on construit un rectangle dont la base
correspond aux valeurs de ce groupe et la hauteur correspond au nombre
d'observations dans le groupe.

L‚Äôhistogramme a une apparence semblable au graphique √† barres
verticales, mais il n'y a pas d'√©cart entre les barres.

En r√®gle g√©n√©rale, l'histogramme poss√®de des barres d'une largeur
√©gale" (Source : [Statistique
Canada, 2021).](https://www150.statcan.gc.ca/n1/edu/power-pouvoir/ch9/histo/5214822-fra.htm)

L'histogramme est particuli√®rement utile pour :

-   **Analyser la distribution** : Comprendre si les donn√©es sont
    normalement distribu√©es, asymm√©triques (angl. *skewness*), ou si
    elles pr√©sentent un plateau (kurtosis).
-   **D√©tecter les valeurs extr√™mes** : Identifier les donn√©es qui
    s'√©cartent du reste de l'ensemble des donn√©es de mani√®re
    signifiante.
-   **Comparer des distributions** : Observer comment diff√©rentes
    sous-populations se comparent les unes aux autres en termes de
    distribution de donn√©es.

Avec `ggplot2` en R, cr√©er un histogramme se fait avec la couche
g√©ometrique `geom_histogram()`. `ggplot2` calcule automatiquement la
taille des intervalles (angl. *bins*) par d√©faut, mais cela peut √™tre
ajust√© manuellement en sp√©cifiant l'argument `binwidth = xyz`dans la
fonction `geom_histogram()`, p. ex. `geom_histogram(binwidth = 30)`.
:::

Avant de cr√©er un histogramme avec le code R, introduisons d'abord une
nouvelle fonction : `rnorm()`. Elle peut √™tre utilis√©e pour cr√©er des
valeurs al√©atoires qui suivent une **loi normale** (angl. *normal
distribution*).

Les arguments que nous pouvons entrer dans la fonction sont :

-   le nombre `n` de valeurs al√©atoires que nous voulons cr√©er

-   la moyenne `mean` de la distribution des valeurs al√©atoires

-   l'√©cart-type `sd` de la distribution des valeurs al√©atoires

Notez que par d√©faut, la fonction utilise `mean = 0` et `sd = 1`, ce qui
correspond √† une **loi normale centr√©e r√©duite** (angl. *standard normal
distribution*). 

Utilisez aussi `?rnorm()`pour acc√©der √† plus d'infos.

Dans le code R suivant, nous utilisons `rnorm()` pour simuler les distributions des tailles des hommes et des femmes en Suisse. 

Selon un article de [*24 heures*](https://www.24heures.ch/calculateur-en-ligne-quelle-taille-faites-vous-par-rapport-aux-autres-191558705635#), en Suisse, les femmes ont une taille moyenne de 164.7 cm tandis que les hommes mesurent 177.4 cm en moyenne. Dans la suite, nous supposons que les √©carts-types sont de +- 5.6 cm pour les femmes et de +- 6.1 cm pour les hommes.


```{r}
#| warning: false
# Simulation de tailles de femmes en Suisse
# Cr√©er 500 valeurs al√©atoires de taille 
# (moyenne = 164.7 et √©cart-type = 5.6) avec la fonction rnorm().
taille_f <- rnorm(500, mean = 164.7, sd = 5.6)

head(taille_f)

# stocker taille_f comme objet de type "data.frame"
taille_f <- as.data.frame(taille_f)

# visualiser taille_f avec un histogramme basique
ggplot(data = taille_f, 
       mapping = aes(x=taille_f)) +
  geom_histogram()

# jouer avec le param√®tre "binwidth" de l'histogramme 
# qui d√©finit l'intervalle de la base de ses barres
ggplot(data = taille_f, 
       mapping = aes(x=taille_f)) +
  geom_histogram(binwidth = 10)

ggplot(data = taille_f, 
       mapping = aes(x=taille_f)) +
  geom_histogram(binwidth = 0.1)

ggplot(data = taille_f, 
       mapping = aes(x=taille_f)) +
  geom_histogram(binwidth = 1)

# stocker l'histogramme comme objet, nomm√© hist1, et modifier sa couleur
hist1 <- ggplot(data = taille_f, 
                 mapping = aes(x=taille_f)) +
  geom_histogram(binwidth = 1, color = "black", fill = "white")

print(hist1)

# Ajouter des couches suppl√©mentaires pour am√©liorer la visualisation
# p. ex. des titres
hist1 <- hist1 + labs(title = "Histogramme des tailles de femmes en Suisse",
                        subtitle = "Simulation bas√©e sur 500 observations",
                        x = "Taille en cm",
                        y = "Fr√©quence") +
        theme_bw()

print(hist1)
```

::: {.callout-tip title="Astuce"}
Un √©l√©ment cl√© des visualisations de donn√©es est la **couleur**. Le
document PDF suivant, cr√©√© par Ying Wei de l'Universit√© de Columbia √†
New York, montre et liste les noms des couleurs dans R. Vous pouvez
copier-coller le nom d'une couleur et l'utiliser dans votre graphique
ggplot2 !

-   [Colors in R](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)
:::

### C'est maintenant √† vous de jouer ! 
Reprenez le code que nous avons utilis√© pour cr√©er `taille_f` et `hist1` et modifiez-le pour cr√©er une nouvelle simulation de taille d'hommes, `taille_h`, et un nouveau histogramme qui montre sa distribution, `hist2`. Jouez avec les param√®tres `binwidth`et la couleur de votre visualisation. Pour cette t√¢che, vous pouvez supposer que les hommes en Suisse ont une taille moyenne (`mean`) de 177,4 cm avec un √©cart-type (`sd`) de 6,1 cm. 

## 4. Les bo√Ætes √† moustaches (angl. *boxplots*)

::: {.callout-note icon="true"}
## √Ä noter
Les **bo√Ætes √† moustaches**, ou **boxplots**, sont un type de graphique pour
repr√©senter la distribution d'un ensemble de donn√©es √† travers cinq
mesures cl√©s :

1.  le minimum (d√©but de la "moustache" ou point extr√™me de minimum)
2.  le premier quartile (Q1 ; d√©but de la bo√Æte)
3.  la m√©diane (Q2 ; ligne qui "coupe la bo√Æte en deux")
4.  le troisi√®me quartile (Q3 ; fin de la bo√Æte) et
5.  le maximum (fin de la moustache ou point extr√™me de maximum)

Ces diagrammes permettent d'identifier rapidement la m√©diane, l'√©tendue
interquartile (angl. *interquartile range* = *IQR*) et les valeurs
√™xtremes potentielles. Ils sont particuli√®rement utiles pour comparer
les distributions entre plusieurs groupes ou variables.
:::

```{r}
#| warning: false
#| echo: false
#| output: true
# Sample data creation
# Replace this with your actual dataframe and column name for the numerical values
set.seed(1238)
df <- data.frame(value = rnorm(300, mean = 5, sd = 2))

# Calculating summary statistics for annotations
summaries <- df %>% 
  summarise(
    Min = min(value),
    Q1 = quantile(value, 0.25),
    Median = median(value),
    Q3 = quantile(value, 0.75),
    Max = max(value),
    IQR = IQR(value)
  ) %>% 
  mutate(
    LowerWhisker = pmax(Q1 - 1.5 * IQR, Min),
    UpperWhisker = pmin(Q3 + 1.5 * IQR, Max)
  )

# Creating the boxplot with annotations
p <- ggplot(df, aes(x = factor(1), y = value)) +
  geom_boxplot() +
  geom_text(data = summaries, aes(x = 1.4, y = Q1, label = paste("Q1 :", round(Q1, 2))), hjust = -0.1) +
  geom_text(data = summaries, aes(x = 1.4, y = Median, label = paste("M√©diane :", round(Median, 2))), hjust = -0.1) +
  geom_text(data = summaries, aes(x = 1.4, y = Q3, label = paste("Q3 :", round(Q3, 2))), hjust = -0.1) +
  geom_text(data = summaries, aes(x = 1.0, y = LowerWhisker, label = paste("Minimum (valeur ext√™me) :", round(LowerWhisker, 2))), hjust = -0.3) +
  geom_text(data = summaries, aes(x = 1.0, y = UpperWhisker, label = paste("Maximum :", round(UpperWhisker, 2))), hjust = -0.3) +
  scale_x_discrete(labels = NULL) + # Hide x-axis labels
  theme_minimal() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  labs(title = "Bo√Æte √† moustache avec des valeurs al√©atoires",
       y = "valeur")


# Display the plot
print(p)
```

Le dataset `mtcars` en R, qui contient des donn√©es sur les
caract√©ristiques de diff√©rents mod√®les de voitures, peut √™tre utilis√©
pour illustrer l'utilisation de boxplots.

Par exemple, pour visualiser la distribution de la consommation de
carburant (`mpg`) des voitures en fonction du nombre de cylindres
(`cyl`), on peut utiliser le code suivant :

```{r}
# Avant de cr√©er le boxplot, v√©rifions d'abord la structure de mtcars :
str(mtcars)
```

Nous pouvons constater que la colonne `cyl` (cylindre) est stock√©e au format num√©rique. 

C'est un probl√®me, car nous voulons comparer la consommation de carburant des voitures √† 4, 6 ou 8 cylindres. Nous devons traiter chacune d'entre elles comme un sous-groupe distinct. Comment faire ?

```{r}
# Transformons donc cyl en facteur
mtcars$cyl <- as.factor(mtcars$cyl)

# Et maintenant nous pouvons construire notre boxplot
box1 <- ggplot(data = mtcars, 
          aes(x=cyl, y=mpg, fill = cyl)) + 
            geom_boxplot(alpha=0.2) + 
              labs(title = "Consommation de carburant (mpg) par nombre de cylindres dans mtcars", x = "Nombre de cylindres", y = "Miles per gallon (mpg)")
print(box1)
  
```
Ce code g√©n√®re un boxplot, `box1`, pour chaque groupe de cylindres dans le
dataset `mtcars`, permettant de comparer facilement la consommation de
carburant entre les voitures avec un diff√©rents nombres de cylindres.

On voit dans le graphique des boxplots que dans `mtcars`, les voitures avec des moteurs ayant plus de cylindres ont aussi tendance √† √™tre moins efficaces en termes de consommation de carburant. Il existe toutefois quelques intersections entre les groupes. C'est-√†-dire qu'il y a des voitures √† 8 cylindres qui sont relativement efficaces en termes de consommation de carburant, surpassant quelques voitures √† 6 cylindres, par exemple. 

## Devoir pour Session 6 (Problem Set 2)

-   **Problem Set 2**

    -   Comme le premier Problem Set, le Problem Set 2 est un QCM sur
        Moodle qui sera accessible pendant 30 minutes du cr√©neau horaire
        de votre groupe de l'exercice.

    -   Assurez-vous que R et RStudio fonctionnent sur votre ordinateur
        portable et qu'il a suffisamment de batterie. Il est de votre
        responsabilit√© de vous en assurer.

    -   Le Problem Set 2 concernera principalement le contenu des
        sessions 4 et 5, √† savoir la visualisation de donn√©es avec
        ggplot2.

    -   Les bases de R qui ont √©t√© trait√©es dans les premi√®res sessions,
        comme par exemple la cr√©ation et l'√©crasement d'objets avec
        l'op√©rateur d'affectation `<-`, sont toutefois requises, car
        la mati√®re se fonde sur ces bases. Veuillez combler vous-m√™me
        les √©ventuelles lacunes √† ce sujet.

-   **Annonce : Questionnaire**

    -   Nous allons √©valuer **un questionnaire sur votre comportement
        d'utilisation des m√©dias** avec R comme autre √©l√©ment important
        du cours.

    -   Le questionnaire est **anonyme** (m√™me pour l'enseignant) et peut
        √™tre rempli en ligne via LimeSurvey jusqu'au **vendredi 19 avril
        2024 √† 23h59**.

    -   Tous les √©tudiant.es recevront prochainement un lien personnel
        d'invitation au questionnaire par e-mail (les r√©ponses seront
        anonymis√©es et m√©lang√©es par le logiciel, l'enseignant ne verra
        que si les personnes invit√©es ont r√©pondu au questionnaire avant
        la date limite).

    -   Chaque √©tudiant(e) qui aura rempli le questionnaire dans les
        d√©lais recevra un **bonus de 3 points dans le Problem Set 4**
        (10% des points).
