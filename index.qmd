---
title: "Exercices M√©thodes II"
date: 2024-02-22
author:
  - name: Julian Maitra
    orcid: 0000-0003-3989-5158
    email: julian.maitra@unifr.ch
    affiliation: 
      - name: Universit√© de Fribourg
        url: https://www.unifr.ch/home/en/
license: "MIT"
copyright: 
  holder: Julian Maitra
  year: 2024
format: html
editor: visual
toc: true
toc-depth: 2
toc-location: left
toc-title: Table des mati√®res
---

# Session 1

```{r}
#| echo: false
#| output: false
library(formatR)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
```

Bienvenue dans la premi√®re le√ßon du cours **Exercices M√©thode II** du
Bachelor en sciences de la communication √† l'Universit√© de Fribourg !

Sur cette page, je vous guiderai dans vos premiers pas avec R.

R est un langage de programmation open-source qui vous permet d'analyser
et de visualiser des donn√©es sur des ph√©nom√®nes de communication
int√©ressants.

Pour utiliser R sur votre ordinateur portable, vous devez d'abord
installer les deux logiciels suivants :

1.  le langage de programmation [R](https://cran.r-project.org)
2.  l'interface [RStudio](https://posit.co/download/rstudio-desktop/)

Notez que nous n'√©crirons le code R que dans RStudio, l'interface. Le
langage de programmation R doit d'abord √™tre install√©, mais il
fonctionnera ensuite en arri√®re-plan. Il n'est donc pas n√©cessaire
d'ouvrir R directement par la suite.

## L'interface RStudio


![Volets
RStudio](https://docs.posit.co/ide/user/ide/guide/ui/images/rstudio-panes-labeled.jpeg)



Dans RStudio, il existe quatre volets diff√©rents :

1.  Le volet **source**
2.  Le volet **console**
3.  Le volet **environnement**
4.  Le volet **output**

## Ex√©cuter un script R

Nous travaillons principalement dans le volet **source**, c'est l√† que
nous √©crivons notre code.

Vous pouvez ouvrir le volet source en cr√©ant un nouveau **R script**
(cliquez sur le signe plus vert dans le coin sup√©rieur gauche). Vous
pouvez r√©√©crire ou copier-coller le calcul simple suivant et l'ins√©rer
dans votre script :

```{r}
#| echo: true
#| output: false
10+14
```

Une fois que nous avons √©crit du code R dans le script, nous pouvons
**l'ex√©cuter** en le s√©lectionnant et en cliquant sur le bouton
d'ex√©cution situ√© au-dessus du volet source (le bouton d'ex√©cution avec
la fl√®che verte √† qui montre √† droite).

C'est alors dans le volet de la **console** o√π le r√©sultat va √™tre
affich√© :

```{r}
#| echo: false
#| output: true
10+14
```

Notez que le nombre entre crochets indique la ligne du r√©sultat. Ici, il
s'agit de 1 car il n'y a qu'une seule ligne.

Voici quelques autres calculs simples, suivi de leurs r√©sultats :

```{r}
#| echo: true
#| output: true
1+2
99-98
2*10
100/2

2^10
```

::: {.callout-tip title="Astuce"}
Pour ex√©cuter le code R plus rapidement, vous pouvez placer votre
curseur sur une ligne de code √† ex√©cuter et utiliser les raccourcis
clavier suivants :

-   Sur **Windows** : <kbd>CTRL</kbd> + <kbd>Enter</kbd>

-   Sur **MacOS** : <kbd>Command</kbd> + <kbd>Enter</kbd>
:::

## Commenter votre code avec un `#`

C'est une bonne pratique de **commenter** son code R. Les commentaires
expliquent ce que le code fait et facilite l'utilisation ult√©rieure et
aussi le partage de code entre personnes (qui ne savent peut-√™tre pas ce
que vous vouliez faire avec votre code).

On commente en ajoutant un symbole **`#`** au d√©but de la ligne de code,
comme ceci :

```{r}
# Ceci est un commentaire, et R l'ignorera lors de l'ex√©cution du script.
```

## L'op√©rateur d'affectation `<-`

L'op√©rateur d'affectation **`<-`** est un op√©rateur cl√© de la
programmation R. Il permet d'attribuer des valeurs aux variables.

```{r}
#| echo: true
# Par exemple, nous pouvons attribuer la valeur 5 √† la variable x :
x <- 5
```

Si vous ex√©cutez ce code, une nouvelle variable, `x`, sera cr√©√©e dans le
volet **environnement** en haut √† droite de RStudio.

::: {.callout-note icon="true"}
## √Ä noter

En g√©n√©ral, la programmation R parle aussi d'**objets**, ou de
**structures de donn√©es**, que vous pouvez cr√©er. C'est pourquoi R est
√©galement appel√© **langage de programmation orient√© objet**. Les
variables √† un √©l√©ment sont des objets tr√®s simples. Au cours de ce
cours, nous d√©couvrirons d'autres types d'objets.
:::

::: {.callout-tip title="Astuce"}
Vous pouvez cr√©er l'operateur d'affectation `<-` avec les raccourcis
clavier suivants :

-   Sur **Windows** : <kbd>Alt</kbd> + <kbd>-</kbd>

-   Sur **MacOS** : <kbd>Option</kbd> + <kbd>-</kbd>
:::

## Variables √† √©l√©ment unique

Vous pouvez **imprimer** (afficher) la valeur d'une variable que vous
avez cr√©√©e, telle que `x`, en tapant le nom de la variable et en
l'ex√©cutant.

```{r}
#| echo: true
x
```

::: {.callout-important title="Important"}
-   Veillez toujours √† ex√©cuter votre code pour cr√©er des variables
    avant de les utiliser pour d'autres op√©rations. Si vous oubliez de
    cr√©er les variables en premier, vous obtiendrez une erreur comme
    r√©sultat.
:::

Par exemple, essayez d'ex√©cuter ce qui suit : `y + z`

Pourquoi cela cr√©e une erreur ? R√©ponse : les variables `y` et `z` n'on
pas encore √©t√© d√©finies !

Pour √©liminer l'erreur, nous devons donc d√©finir `y` et `z`.

```{r}
#| echo: true
#| output: true
y <- 7
z <- 3 

# Essayons encore une fois :
y + z
```

Maintenant √ßa marche ! üòÄ

::: {.callout-important title="Important"}
-   Sachez aussi que si vous attribuez une nouvelle valeur √† une
    variable existante, l'ancienne valeur sera √©cras√©e !
:::

```{r}
#| echo: true
# Notez que si vous ex√©cutez toutes les lignes de code suivantes, la variable x se voit attribuer la derni√®re valeur ex√©cut√©e : 4. Les valeurs 5 et 100 sont ecras√©es lors de l'ex√©cution du code.
x <- 5
x <- 100
x <- 4
x
```

### Les diff√©rents types de variable : num√©riques, textuelles et logique

Jusqu'√† pr√©sent, nous avons cr√©√© des variables de **type num√©rique**,
telles que `x` (valeur = 5).

Cependant, ce n'est pas le seul type de variable dans R.

::: {.callout-note icon="true"}
## √Ä noter

Dans R, il existe diff√©rents types de variables :

-   les variables **num√©riques**

-   les variables **textuelles**, √©galement appel√©es *character strings*
    (cha√Ænes de caract√®res).

-   les variables **logiques** avec les valeurs TRUE et FALSE (VRAI et
    FAUX)
:::

```{r}
#| echo: true
# Regardons quelques exemples avec du code ! (faut tout ex√©cuter !)

# variables num√©riques :
a <- 100
b <- 77

age <- 21
Insta_likes <- 1539

# variables textuelles (toujours ajouter des guillemets !)
c <- "chien"
d <- "chat"

Comm_TikTok <- "wsh"
Moliere <- "il n‚Äôest rien d‚Äô√©gal au tabac : c‚Äôest la passion des honn√™tes gens"

# variables logiques :

e <- TRUE
f <- FALSE
```

Les variables logiques peuvent √™tre utiles quand vous travaillez avec
des **cat√©gories binaires**.

Par exemple : il est souvent utile de classer les personnes ayant
r√©pondu √† un questionnaire en cat√©gories binaires, telles que :

-   homme/femme

-   mineur/majeur

-   conservateur/lib√©ral

-   etc.

```{r}
#| echo: true
# Si Marc √©tait mineur et Claire majeure, nous les classerions comme suit : 

Marc <- FALSE
Claire <- TRUE

# Dans cet exemple, la variable logique indique si une personne est majeure (TRUE) ou pas (FALSE)

```

## Variables √† plusieurs √©l√©ments : vecteurs

Les **vecteurs** constituent un autre type de variable (ou type d'objet)
essentiel dans la programmation R. Il s'agit de variables comportant
**plusieurs** √©l√©ments.

Vous pouvez cr√©er des vecteurs avec l'operateur d'affectation `<-` et la
**fonction de concatenation** `c()`.

```{r}
#| echo: true
# Voici quelques exemples avec du code ! (faut tout ex√©cuter !)

# un vecteur num√©rique (notez qu'il faut toujours s√©parer les valeurs avec des virgules)
v1 <- c(1, 2, 3)
```

Vous pouvez afficher la valeur de `v1` en tappant son nom et l'ex√©cutant
:

```{r}
#| echo: true
v1 
```

::: {.callout-note icon="true"}
## √Ä noter

En R, une **fonction** est un morceau de code con√ßu pour effectuer une
t√¢che sp√©cifique, souvent avec des param√®tres variables. Ces param√®tres
d'entr√©e sont √©galement appel√©s les **arguments** de la fonction.
:::

Prenons l'exemple de la fonction `c()` qui cr√©e des vecteurs :

-   les arguments de cette fonction doivent √™tre ins√©r√©s entre les
    crochets sous la forme de valeurs s√©par√©es par des virgules (pour
    chaque √©l√©ment du vecteur).

-   Un vecteur √† deux √©l√©ments : `c(2, 4)`

-   Un vecteur √† trois √©l√©ments : `c(3, 6, 9)`

Maintenant, regardons encores quelques exemples de vecteurs de
**diff√©rents types** :

```{r}
#| echo: true
# vecteurs num√©riques 
w <- c(-10, 100, 4, -88)

likes_comments_shares <- c(513, 34, 102)

# vecteurs textuels (toujours ajouter des guillemets pour chaque √©l√©ment !)
animaux <- c("chat", "chien", "cheval", "chenille")

Comm_Insta <- c("trop cool", "wsh", "c'est quoi ?")

humains <- c("Claire", "Clarissa", "Theresa", "Marc", "Alma")

# vecteurs logiques :
femme <- c(TRUE, TRUE, TRUE, FALSE, TRUE)

```

::: {.callout-caution collapse="false"}
## Attention

Dans R, on ne peut g√©n√©ralement pas m√©langer les valeurs num√©riques,
textuelles et logiques dans le m√™me vecteur !
:::

## Devoir pour Session 2

-   Si ce n'est pas encore fait : Installez R et RStudio sur votre
    ordinateur.

-   Lisez ensuite encore une fois ce script et ex√©cutez toutes les
    sections de code sur votre ordinateur.

-   Essayez de r√©soudre vous-m√™me les √©ventuels messages d'erreur en
    adaptant le code.

# Session 2

## R√©p√©tition rapide de session 1

```{r}
#| echo: true
#| output: false
#| error: true
# Script de r√©p√©tition

# Avez-vous compris comment R traite les diff√©rents types de variables ?
# Quelle est la diff√©rence entre a et b ?

a <- 5
b <- "5"

# Comment afficher a et b ?


# Alternative : avec la fonction print(), qui augmente la compr√©hension ult√©rieure du code


# Pourquoi le code suivant produit-il une erreur ?
a*b

# Le code suivant corrige √† nouveau l'erreur, pourquoi ?
b <- 5
a*b

# V√©cteurs
v1 <- c(1,2,3,4)
v1

# Vous pouvez cr√©ez des nombres succesifs avec un colon :
v2 <- c(1:10)
v2

v3 <- c("salut", "le", "pote")
v4 <- c(TRUE, FALSE, FALSE)

```

::: {.callout-tip title="Astuce"}
Vous pouvez utiliser la fonction `class()` pour v√©rifier le type d'un
objet, p. ex. (ex√©cutez vous-m√™me !) :

-   `class(c(1,2,3))`

-   `class(c("Hello", "World"))`

-   `class(c(TRUE,TRUE,FALSE))`
:::

## Donn√©es en forme de tableau

Les donn√©es sous forme de tableaux, avec des lignes et des colonnes,
sont au c≈ìur des m√©thodes quantitatives dans les sciences de la
communication.

Dans R, il existe plusieurs structures de donn√©es en format de tableau,
notamment :

-   Les **matrices**

-   Les **data frames**

-   D'autres types, tels que les **tibbles**, qui sont en fait des data
    frames adapt√©s √† des paquets R sp√©cifiques (nous traiterons ce sujet
    plus tard dans le cours).

::: {.callout-important title="Important"}
-   Il est de convention qu'un tableau de donn√©es pr√©sente les **unit√©s
    statistiques** par **ligne** (angl. *row*).
-   Les **variables** ou caract√©ristiques de ces unit√©s statistiques
    sont indiqu√©es en cons√©quence par **colonnes** (angl. *column*).
:::

::: {.callout-note icon="true"}
## √Ä noter

Selon le type de donn√©es, surtout en recherche empirique en sciences
sociales dont font partie les sciences de la communication, les unit√©s
statistiques peuvent √™tre :

-   des **participants** √† un questionnaire ou √† une exp√©rimentation

-   des **documents** (p. ex. articles de presse, posts sur r√©seaux sociaux)

-   des **observations/ cas** (p. ex. des profils sur r√©seaux sociaux, des
    entreprises m√©diatiques)
    
Dans ces jeux de donn√©es, par convention, chaque ligne repr√©sente une unit√© statistique (ou un participant, un document, une observation), tandis que chaque colonne repr√©sente les variables qui ont √©t√© collect√©es pour chaque unit√© statistique.
:::
::: {.callout-note icon="true"}
## √Ä noter
La taille d'un jeu de donn√©es est indiqu√©e par **le nombre d'unit√©s
statistiques n**. 

-   Par exemple, si 49 personnes ont r√©pondu √† un questionnaire, nous
    parlons donc d'un √©chantillon de n = 49 participants.
:::

Voici un mod√®le de la mani√®re dont on devrait structurer les r√©ponses √†
un questionnaire avec n participants et X questions :

```{r}
#| echo: false
#| output: true
id <- c("personne_1", "personne_2", "personne_3", "etc.", "personne_n")
question_A <- c("r√©ponse_a_A", "r√©ponse_a_A", "r√©ponse_a_A", "...", "r√©ponse_a_A")
question_B <- c("r√©ponse_a_B", "r√©ponse_a_B", "r√©ponse_a_B", "...", "r√©ponse_a_B")
question_C <- c("r√©ponse_a_C", "r√©ponse_a_C", "r√©ponse_a_C", "...", "r√©ponse_a_C")
etc. <- c("...", "...", "...", "...", "...")
question_X <- c("r√©ponse_a_X", "r√©ponse_a_X", "r√©ponse_a_X", "...", "r√©ponse_a_X")

questionnaire = data.frame(id, question_A, question_B, question_C, etc., question_X)
questionnaire
```

Dans ce mod√®le, l'unit√© statistique de ce jeu de donn√©es est la personne
qui a r√©pondue au questionnaire (un participant). Chaque ligne correspond donc √† une
personne diff√©rente. Les variables, en revanche, sont les diff√©rentes questions qui ont √©t√© enregistr√©es pour chaque participant.

Regardons maintenant quelques objets R sous forme de tableau :

## Les matrices

Les **matrices** sont des objets plut√¥t math√©matique. Elles doivent
notamment √™tre compos√© de donn√©es de m√™me type, c'est √† dire num√©rique,
textuel, logique, etc.

On peut cr√©er des objets matriciels avec la commande **`matrix()`**,
avec les arguments suivants :

-   un vecteur de valeurs (p. ex. `c(1,2,3,4,5,6)`)

-   le nombre de lignes (`nrow=`),

-   le nombre de colonnes (`ncol=`) et

-   la *direction* de remplissage des valeurs, c'est-√†-dire par lignes
    (`byrow = TRUE`) ou par colonnes (`byrow = FALSE`).

Cr√©ons quelques matrices exemplaires avec du code R maintenant.

```{r}
#| echo: true
#| output: false
m1 <- matrix(c(1,2,3,4,5,6), nrow = 2, ncol = 3, byrow = FALSE)

print(m1)


m2 <- matrix(c(1:6), nrow = 2, ncol = 3, byrow = TRUE)

print(m2)

# Quelle est la diff√©rence entre m1 et m2 au niveau du code ?

```

::: {.callout-note icon="true"}
## √Ä noter

Si vous ne sp√©cifier pas tous les arguments d'une fonction, R va tenter
d'utiliser des arguments par d√©fauts.
:::

```{r}
# On peut p. ex. cr√©er une matrice sans sp√©cifier tout les arguments de la fonction matrix()
m3 <- matrix(c(1:10), nrow = 5)

print(m3)
```

Vous pouvez extraire des √©l√©ments individuels ou des parties d'une
matrice avec des **parenth√®ses carr√©es `[]`** en sp√©cifiant les lignes
et les colonnes concern√©es.

```{r}
#| echo: true
#| output: true
# Cr√©ons d'abord un matrice m4 avec 100 √©l√©ments :
m4 <-  matrix(c(1:100), nrow = 10, byrow = TRUE)
print(m4)

# Extraire le deuxi√®me √©l√©ment de la troisi√®me ligne :
m4[3,2]

# Extraire les cinq premiers √©l√©ments de la dixi√®me ligne :
m4[10, c(1:5)]

# Extraire tous les √©l√©ments de la premi√®re ligne :
m4[1,]

# Extraire tous les √©l√©ments de la troisi√®me colonne :
m4[,3]

# Extraire la moiti√© sup√©rieure de la matrice :
m4[c(6:10),]

```

## Les data frames

::: {.callout-note icon="true"}
## √Ä noter

Les **data frames** (fran√ßais : *cadre de donn√©es*) sont le type de
donn√©e en forme tableau le plus commun dans R. Cette structure de donn√©e
peut notamment √™tre compos√© de donn√©es de diff√©rents types (num√©rique,
textuel, logique).
:::

Cr√©ons un data frame avec la fonction `data.frame()` maintenant. Nous
appelons ce type d'objets d√©sormais un **jeu de donn√©es**.

```{r}
#| echo: true
#| output: false

# Cr√©ons d'abord un vecteur textuel avec les noms de certains animaux du film L'√¢ge de glace.
name <- c("Manny", "Sid", "Diego", "Ellie", 
          "Peaches", "Scrat", "Rudy", "Buck")

#Un second vecteur textuel indique l'esp√®ce de chaque animal.
species <- c("mammoth", "sloth", "sabertooth", "mammoth", 
             "mammoth", "squirrel", "dinosaur", "weasel")

# Un troisi√®me vecteur logique indique si chaque animal est une femelle
female <- c(FALSE, FALSE, FALSE, TRUE, 
            TRUE, FALSE, FALSE, FALSE)

# Un quatri√®me vecteur num√©rique indique l'√¢ge en ann√©es de chaque animal.
age <- c(30, 20, 35, 25, 
         7, 4, 100, 28)

# Un cinqui√®me tableau num√©rique indique le poids en kg de chaque animal.
weight <- c(5000, 80, 400, 4000, 
            1000, 1, 10000, 3)

# La fonction data.frame() permet d'utiliser les vecteurs pour former un tableau de donn√©es.
ice_age_df <- data.frame(name, species, female, age, weight)

```

Nous pouvons afficher l'objet `ice_age_df` en ex√©cutant son nom ou en
utilisant la fonction `print()` :

```{r}
print(ice_age_df)
```

### Quelques fonctions utiles pour analyser les data frames

Il existe plusieurs **fonctions utiles** dans R qui vous permettent
d'analyser les propri√©t√©s de jex de donn√©es de type data frame (et
d'autres types d'objets R), comme p. ex. :

-   `dim()` : Retourne les dimensions d'un jeu de donn√©es - le nombre de
    lignes et de colonnes.

-   `head()` : Affiche les six premi√®res lignes du jeu de donn√©es.

-   `str()` : Fournit la structure du jeu de donn√©es, y compris

    -   le type de variable de chaque colonne,

    -   le nombre d'observations et

    -   les premi√®res entr√©es de chaque colonne.

        C'est un moyen rapide de se faire une id√©e du contenu de votre
        jeu de donn√©es.

-   `summary()`: Donne un r√©sum√© du jeu de donn√©es, y compris des
    statistiques telles que

    -   la moyenne,

    -   la m√©diane,

    -   le minimum et le maximum pour les variables num√©riques, et

    -   les fr√©quences pour les variables factorielles.

        Cette fonction est utile pour obtenir rapidement une vue
        d'ensemble des statistiques.

```{r}
#| echo: true
#| output: true

# Utilisons ces fonctions pour analyser l'objet ice_age_df

dim(ice_age_df)
head(ice_age_df)
str(ice_age_df)
summary(ice_age_df)

```

::: {.callout-tip title="Astuce"}
Une autre astuce utile consiste √† utiliser le **`$`** pour **extraire
des colonnes sp√©cifiques** d'un jeu de donn√©es.
:::

```{r}
#| echo: true
#| output: true
# P. ex. :
ice_age_df$name

# Essayez vous-m√™me et extrayez d'autres colonnes de ice_age_df √† l'aide du $ !
```

## Fonctions statistiques de base

Il existe dans R toute une palette de fonctions statistiques qui vous
permettent d'√©valuer principalement des donn√©es de type num√©rique.
Quelques fonctions utiles pour les statistiques descriptives de base :

-   `mean()` : Calcule la moyenne arithm√©tique

-   `median()` : Calcule la m√©diane

-   `sd()` : Calcule l'√©cart-type (angl. *standard deviation*)

-   `var()` : Calcule la variance

```{r}
#| echo: true
#| output: false
a1 <- c(1,2,100)

mean(a1)

median(a1)

sd(a1)

var(a1)
```

```{r}
#| echo: false
#| output: true
a1 <- c(1,2,100)

mean(a1)

median(a1)

sd(a1)

var(a1)
```

## Les facteurs

Un autre type de variable cl√© dans R est ce que l'on appelle les
**facteurs**, qui sont essentiellement des **variables cat√©gorielles**.

::: {.callout-note icon="true"}
## √Ä noter

Les facteurs sont des variables qui prennent un nombre limit√© de valeurs
diff√©rentes (appel√©es *levels* dans R).

Il existe deux sous-type de facteurs :

-   Les **facteurs nominaux** (sans ordre) : toutes les cat√©gories sont
    √©quivalentes les unes aux autres. Il n'y a pas de hi√©rarchisation.

    -   Exemples : le genre et l'appartenance √† un parti

-   Les **facteurs ordinaux** (avec un ordre): il y a un ordre ou une
    hi√©rarchie sp√©cifi√© parmi les cat√©gories (p. ex. des niveaux tels
    que *faible*, *moyen*, *√©lev√©*).

    -   Exemples : niveau d'√©ducation, cohortes d'√¢ge
:::

Vous pouvez cr√©er un facteur nominal √† l'aide de la fonction `factor()`
et v√©rifier ses cat√©gories avec `levels()`. Voici un exemple :

```{r}
#| echo: true
#| output: true
# Cr√©er un vecteur de donn√©es cat√©gorielles, d'abord de type textuel
genre <- c("homme", "femme", "femme", "femme", "homme")

# Le convertir ensuite en facteur
facteur_genre <- factor(genre)

# Voir les niveaux du facteur genre
levels(facteur_genre)

# Imprimer le facteur (montre aussi les niveaux)
print(facteur_genre)
```

Et voici comment cr√©er un facteur ordinal :

```{r}
#| echo: true
#| output: true
# Voici un vecteur textuel avec des tailles de T-shirt
tailles <- c("Small", "Medium", "Large", "Medium", "Small")

# On le transforme en facteur ordinal en sp√©cifiant les arguments suivants :
tailles_facteur <- factor(tailles, order = TRUE, levels = c("Small", "Medium", "Large"))

levels(tailles_facteur)

print(tailles_facteur)

```

Transformons maintenant la colonne `species` de notre jeu de donn√©es
`ice_age_df` en facteur avec la fonction `as.factor()`:

```{r}
#| echo: true
#| output: true
# V√©rifions d'abord la structure de l'objet ice_age_df :
str(ice_age_df)

# Transformation en facteur :
# ice_age_df$species <- as.factor(ice_age_df$species)

# V√©rifions encore une fois la structure de l'objet :
# str(ice_age_df)

```

C'est maintenant √† vous de transformer la colonne `name` de
`ice_age_df`en facteur !

## Le r√©p√©rtoire de travail

::: {.callout-important title="Important"}
Dans R, le **r√©pertoire de travail** (angl. *working directory*) fait
r√©f√©rence au dossier de votre ordinateur dans lequel R lit et enregistre
les fichiers par d√©faut. Il s'agit d'un concept crucial dans la
programmation R, car il d√©termine l'endroit o√π R recherche les fichiers
√† lire et l'endroit o√π il place les fichiers lorsque vous les
enregistrez.
:::

Vous pouvez d√©finir votre r√©pertoire de travail avec la fonction
**`setwd()`**.

Une possibilit√©, c'est de le faire manuellement dans le volet *output*
en bas √† droite :

1.  Naviguez sur l'onglet **Files**
2.  Cliquez sur les trois petits points **...** tout √† droite
3.  Choisissez un dossier sur votre ordinateur qui peut servir de
    r√©pertoire de travail (vous devez peut-√™tre en cr√©er un d'abord et
    lui donner un nom utile, p.ex. "ex_meth_sp24"
4.  Cliquez ensuite sur la petite **roue bleue** (More) et choisissez
    **Set as Working Directory**
5.  Vous pouvez ensuite copier et coller le code R qui d√©finit le
    r√©pertoire de travail depuis l'onglet de la console et l'inclure
    dans votre script R

Sur l'ordinateur de l'enseignant, ce code est le suivant :
`setwd("C:/Users/julim/switchdrive/001_Exercices_Methodes_2_SP_22/R")`
**Attention** : Ce code ne marche naturellement pas sur votre machine.
Il faut l'adapter et inclure un chemin de fichier de votre ordinateur.

Vous pouvez ensuite v√©rifier si le r√©pertoire de travail a √©t√©
correctement d√©fini avec la fonction `getwd()`

## Devoir pour Session 3 (Problem Set 1)

-   **Problem Set 1**

    -   Le Problem Set 1 est un QCM sur Moodle qui sera accessible
        pendant les 30 premi√®res minutes de l'exercice.

    -   Assurez-vous que R et RStudio fonctionnent sur votre ordinateur
        portable et qu'il a suffisamment de batterie. Il est de votre
        responsabilit√© de vous en assurer.

    -   Dans le Problem Set 1, il y a √† la fois des questions que vous
        devez r√©soudre avec du code R et des questions de compr√©hension
        qui peuvent √™tre r√©solues sans code. Vous devez donc √™tre
        capable non seulement d'ex√©cuter le code, mais aussi d'en
        comprendre l'objectif.

    -   R√©p√©tez le contenu des sessions 1 et 2 sur votre ordinateur afin
        de bien vous pr√©parer pour le Problem Set 1.

    -   Assurez-vous que toutes les parties du code fonctionnent sans
        message d'erreur.

-   **Attention** :

    -   Vous devez tous venir la semaine prochaine dans le groupe dans
        lequel vous √™tes inscrits via my.unifr (A, B, C, D) si vous
        voulez participer au Problem Set 1.

    -   Chaque √©tudiant.e n'aura acc√®s qu'au Problem Set 1 de son
        groupe.

    -   Les personnes qui ne sont inscrites dans aucun groupe ne peuvent
        pas valider le Problem Set 1.
